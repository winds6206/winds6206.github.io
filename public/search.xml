<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cloud NAT的限制</title>
    <url>/2021/05/10/Cloud-NAT%E7%9A%84%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因公司產品是採用 GKE 的基礎設施，為了讓 GKE 對外有一個 static IP，所以有加上 Cloud NAT 的功能，一開始加上去並沒有什麼問題，但日子長了之後，某一天發現要再擴增 Node 時，沒有辦法順利擴增，查了好一段時間才知道，原來是 Cloud NAT 導致要擴增 Node 時沒有辦法擴增，這其實很難想像得到，因為基本上不會有理由去懷疑是 Cloud NAT 所致。</p>
<p>所以這邊紀錄一下遇到的問題，說不定你也正遇到跟我一樣的問題</p>
<span id="more"></span>

<h2 id="Cloud-NAT"><a href="#Cloud-NAT" class="headerlink" title="Cloud NAT"></a>Cloud NAT</h2><p>在 Cloud NAT 的進階設定中，有一個欄位叫做「每個 VM<br>執行個體的最低通訊埠數量」，如果你是使用英文介面會顯示「Minimum ports per VM instance」，就是這個數值會去影響可以運行的機器數量，後來參考外國的一篇文章才了解到此設定的重要性(參考的資料放在文後)，此數值不僅會決定你所選取的 VPC 內可以使用的機器數量，還會決定你的每台機器從 NAT 出去的連線數量，以下詳細說明</p>
<h3 id="連線量"><a href="#連線量" class="headerlink" title="連線量"></a>連線量</h3><p>「每個 VM 執行個體的最低通訊埠數量」所填入的數值，本質意義是在說明: 你指定的 VPC 底下的每一台機器透過 Cloud NAT 到相同目的 IP 與 port 且使用相同的通訊協定(TCP or UDP) 的連線數量。</p>
<p>舉例來說：預設數值為64，我的 VPC 內有三台機器，其中一台機器連線到 <code>TCP 1.1.1.1:1000</code> 此目的的數量有64條，這時此台機器要再連線此目的的連線就會被 drop 掉，導致後續的連線會異常，但是還是可以連線到「其他目的」。</p>
<blockquote>
<p>此處的「其他目的」是指與 <code>TCP 1.1.1.1:1000</code> 不同的「目的IP」或「目的Port」或「通訊協定」</p>
</blockquote>
<p>以下都是可以正常連線的目的，而且連線數是個別分開計算，這樣舉例會比較清楚</p>
<ul>
<li>UDP 1.1.1.1:1000</li>
<li>TCP 2.2.2.2:1000</li>
<li>UDP 2.2.2.2:1000</li>
<li>TCP 2.2.2.2:2000</li>
<li>UDP 2.2.2.2:3000</li>
</ul>
<h3 id="機器數量"><a href="#機器數量" class="headerlink" title="機器數量"></a>機器數量</h3><p>再來要討論「每個 VM 執行個體的最低通訊埠數量」的數值要怎麼計算 VPC 底下可以開幾台 Node</p>
<p>每個 Cloud NAT 的 IP 有 65536 個連接埠分別給 TCP 與 UDP 使用，其中有 1024 個是公認通訊埠號(well-known port numbers)，所以實際可使用的連接埠為 64512(65536-1024)，如果使用 Google 給的預設數值64，那每個 NAT IP 可以支援相對應 VPC 底下高達 1008 台 Node (64512/64)，但是缺點就是可乘載的連線數量相對就比較少，如果想要擴增可乘載的機器數量，可以增加 NAT IP 來解決，如果在 Cloud NAT 放上第二組 NAT IP，此時 Node 就可以到 2016(1008*2) 那麼多。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://medium.com/bluekiri/high-availability-nat-gateway-at-google-cloud-platform-with-cloud-nat-8a792b1c4cc4">https://medium.com/bluekiri/high-availability-nat-gateway-at-google-cloud-platform-with-cloud-nat-8a792b1c4cc4</a></li>
</ul>
]]></content>
      <tags>
        <tag>GKE</tag>
        <tag>GCP</tag>
        <tag>Google Cloud Platform</tag>
        <tag>Cloud NAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo建立草稿</title>
    <url>/2021/05/10/Hexo%E5%BB%BA%E7%AB%8B%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 Hexo 來當作技術部落格不僅簡單且快速，在剛開始架設完成後，可以使用指令 <code>hexo new [title]</code> 來建立文章並且撰寫，但是這樣的方式會延伸一個問題，如果這篇文章還處理撰寫的階段，但是我有修改其他已完成的文章需要發佈出去，但是不想把未完成的文章也一起發佈，此時就會有一些困擾，此篇會來說明如果使用 Hexo 的草稿功能。</p>
<span id="more"></span>

<h2 id="Hexo-草稿"><a href="#Hexo-草稿" class="headerlink" title="Hexo 草稿"></a>Hexo 草稿</h2><p>一般來說，我們建立文章都是使用此指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [Title] [FileName]</span><br></pre></td></tr></table></figure>

<p>如果今天要建立 Hexo 草稿，我們可以將上述指令改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new draft [Title] [FileName]</span><br></pre></td></tr></table></figure>

<p>那此時產生出來的草稿會放在 <code>./source/_drafts</code></p>
<blockquote>
<p>如果是使用 <code>hexo new [title]</code> 則會放在 <code>./source/_posts</code></p>
</blockquote>
<p>當我們要發佈一篇文章時，我們會使用 <code>hexo g</code> 和 <code>hexo d</code> 來編譯產生靜態檔與發佈文章，而草稿目錄內的文章不會被發佈出去，是 <strong>因為 <code>hexo g</code> 並不會編譯 <code>./source/_drafts</code> 底下的檔案</strong>。</p>
<p>如果放在草稿目錄底下的文章完成後，想在本機先預覽檢查時，可以使用此指令</p>
<blockquote>
<p>此處「文後討論」有補充說明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s --draft</span><br></pre></td></tr></table></figure>

<p>確認文章沒問題後，我們就可以將草稿 publish，使用此指令</p>
<blockquote>
<p>這邊的 publish 是將檔案從 _drafts 移動到 _posts</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [FileName]  # 這邊是接 FileName，不包含副檔名 .md</span><br></pre></td></tr></table></figure>

<p>接下來就跟放在 _posts 底下的文章發佈沒有兩樣，先進行移除舊的靜態檔與快取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo cl</span><br></pre></td></tr></table></figure>

<p>然後進行編譯的動作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>最後再發佈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>看完上述，你可能會想，那能不能讓 <code>hexo s</code> 自動將 _drafts 底下的檔案自動預覽出來，而不要在指令後面又多加一個參數 <code>--draft</code>?</p>
<p>答案是 可以的!</p>
<p>此時要去調整 <code>./_config.yml</code> 內的設定，將下面的參數值由 false 調整為 true 即可</p>
<blockquote>
<p>非 themes 底下的 _config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render_drafts: true</span><br></pre></td></tr></table></figure>

<p>調整之後，以後要預覽 _drafts 內的文章，就跟一般放在 _posts 底下的一樣，只要使用 <code>hexo s</code> 通通都可以在本機預覽得到。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://www.dazhuanlan.com/2019/11/02/5dbc7ecc737a5/">https://www.dazhuanlan.com/2019/11/02/5dbc7ecc737a5/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
        <tag>Hexo草稿</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP-FPM行程優化</title>
    <url>/2021/04/29/PHP-FPM%E8%A1%8C%E7%A8%8B%E5%84%AA%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期公司內部 PHP-FPM 有頂到一些行程相關的上限，導致網頁要處理後端程式時無法處理，進而造成服務異常。 而這樣子的問題不外乎可以從 LOG 去看到一些觸發到這個問題的根本原因是什麼。</p>
<p>以下列了兩個行程不夠時常見的 Error Log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING: [pool www] server reached pm.max_children setting (5), consider raising it</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING: [pool www] seems busy (you may need to increase pm.start_servers, or pm.min&#x2F;max_spare_servers), spawning 32 children, there are 0 idle, and 19 total child</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>PHP-FPM 行程優化相關參數，以下為預設值，需要依照每台機器狀態不同去調教</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm &#x3D; dynamic</span><br><span class="line">pm.max_children &#x3D; 5</span><br><span class="line">pm.start_servers &#x3D; 2</span><br><span class="line">pm.min_spare_servers &#x3D; 1</span><br><span class="line">pm.max_spare_servers &#x3D; 3</span><br><span class="line"></span><br><span class="line">pm.max_requests &#x3D; 500</span><br><span class="line">pm.process_idle_timeout &#x3D; 10s # 需搭配 pm &#x3D; ondemand</span><br></pre></td></tr></table></figure>

<p>以下會針對每個項目去解釋其用途</p>
<h2 id="pm-Process-Manager"><a href="#pm-Process-Manager" class="headerlink" title="pm (Process Manager)"></a>pm (Process Manager)</h2><p>pm 為行程管理(Process Manager) 的縮寫，此參數主要是在設定 pm 要使用哪種模式來管理行程，可以區分兩大類型，共三種模式可以選擇，預設是使用 dynamic</p>
<h3 id="固定行程數量"><a href="#固定行程數量" class="headerlink" title="固定行程數量"></a>固定行程數量</h3><ul>
<li>static: 設定此模式，只有 <code>pm.max_children</code> 參數會生效，行程數量則根據 <code>pm.max_children</code>，效能較好，因為 child process 會保持一個固定的數量，但是比較佔記憶體，因為即便請求較少量時，依然會佔用，所以較不建議使用此模式</li>
</ul>
<h3 id="動態行程數量"><a href="#動態行程數量" class="headerlink" title="動態行程數量"></a>動態行程數量</h3><p>皆根據 <code>pm.max_children</code>、<code>pm.start_servers</code>、<code>pm.min_spare_servers</code>、<code>pm.max_spare_servers</code> 動態調整</p>
<ul>
<li>dynamic: 根據使用量用多寡開行程，但當使用量比較低時，會保留固定行程(根據 <code>pm.min_spare_servers</code> 或 <code>pm.max_spare_servers</code>)，隨時等著接收新的連線</li>
<li>ondemand: 用多少量就開多少行程</li>
</ul>
<h4 id="dynamic-實際運作"><a href="#dynamic-實際運作" class="headerlink" title="dynamic 實際運作"></a>dynamic 實際運作</h4><p>當我們設定 <code>pm = dynamic</code> 並啟動時，首先會產生一定數量的行程(根據 <code>pm.start_servers</code>)，此參數可以想像成是最小數量的子程序，而最大數量的子程序則根據 <code>pm.max_children</code>，有了最大和最小子程序數量，也就是說服務過程中子程序數量會在最大和最小子程序數量間變化。</p>
<p>而閒置的子程序數量則由 <code>pm.min_spare_servers</code>、<code>pm.max_spare_servers</code> 控制，超過 <code>pm.max_spare_servers</code> 的閒置子程序則會被 Kill。</p>
<p>因為 dynamic 模式可以針對伺服器的回應做最大的優化，但相反的代價是可能造成更多記憶體的佔用，這邊舉例來說，假設 <code>pm.max_spare_servers = 10</code>、<code>pm.max_children = 20</code>，在某個尖峰時段，這時候最大數量的子程序 20 個都處於忙碌狀態，0個閒置的子程序，過了尖峰時段，請求下降，而當初忙碌的 20 個子程序目前處於閒置狀態，此時 PHP-FPM 只會 Kill 掉 10 個子程序，而最後剩下 10 個閒置的子程序來等待請求，這也就是會造成在尖峰後請求數大量減少後，記憶體卻沒有大量降低的主要原因，而如果把主機重啟，記憶體則會將得更低，這是因為重啟用子程序數量會變成最小閒置行程數量(<code>pm.min_spare_servers</code>)</p>
<h4 id="ondemand-實際運作"><a href="#ondemand-實際運作" class="headerlink" title="ondemand 實際運作"></a>ondemand 實際運作</h4><p><code>pm = ondemand</code> 的運作方式與 dynamic 恰好相反，dynamic 針對伺服器的回應做最大的優化，而 ondemand 則是最佳化記憶體。</p>
<p>而運作方式是，每個閒置的子程序在持續閒置超過 <code>pm.process_idle_timeout</code> 設定的時間，就會被 Kill 掉，這樣的模式讓主機在尖峰時期過後可以自然地降低記憶體的使用率，如果長時間都沒有請求連線時，只會有一個 PHP-FPM 主程序。</p>
<p>那壞處則是，如果遇到尖峰時期，或 <code>pm.process_idle_timeout</code> 設定得太短的話，會造成伺服器頻繁的建立子程序，而造成效能不佳</p>
<h2 id="pm-max-children-最大行程數量"><a href="#pm-max-children-最大行程數量" class="headerlink" title="pm.max_children(最大行程數量)"></a>pm.max_children(最大行程數量)</h2><p><code>pm.max_children</code> 參數在 <code>pm</code> 等於 <code>static</code> 即為開啟的行程數，而在 <code>dynamic</code> 與 <code>ondemand</code> 模式下，則是代表最大可開啟的行程數量。</p>
<p>最大行程數量的多寡是根據本身主機的記憶體大小來決定，當記憶體越大時，就可以設定較多的行程數量。 此設定值如果設太小的話會造成處理請求的速度下降，設定太大的話會造成當機，因為記憶體耗盡，所以要依硬體資源來調較。</p>
<p>可以利用以下指令去查詢行程使用的記憶體量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ylC php-fpm --sort:rss</span><br><span class="line"></span><br><span class="line">S   UID     PID    PPID  C PRI  NI   RSS    SZ WCHAN  TTY          TIME CMD</span><br><span class="line">S     0       1       0  0  80   0  4760 20195 do_epo ?        00:02:11 php-fpm</span><br><span class="line">S    33       9       1  0  80   0 20260 22581 -      ?        00:01:20 php-fpm</span><br><span class="line">S    33       8       1  0  80   0 20464 22582 -      ?        00:01:42 php-fpm</span><br><span class="line">S    33       7       1  0  80   0 20476 22584 -      ?        00:01:43 php-fpm</span><br></pre></td></tr></table></figure>

<p>RSS 欄位為子程序使用的記憶體大小，單位為KB，20476 約莫 20MB，但是因為每個子程序所使用的記憶體大小都不太一樣，所以我們可以使用下面的指令來求出子程序平均使用記憶體大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps --no-headers -o &quot;rss,cmd&quot; -C php-fpm | awk &#39;&#123; sum+&#x3D;$1 &#125; END &#123; printf (&quot;%d%s\n&quot;, sum&#x2F;NR&#x2F;1024,&quot;Mb&quot;) &#125;&#39;</span><br></pre></td></tr></table></figure>

<p>至於 <code>pm.max_children</code> 應該要設定多少才合理，以下有一個計算公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.max_children &#x3D; Total RAM &#x2F; Max child process size</span><br></pre></td></tr></table></figure>

<blockquote>
<p>這邊的 Total RAM 需要扣除已經使用的記憶體，例如系統或其他程序使用後所剩餘的記憶體</p>
</blockquote>
<h2 id="pm-start-servers-初始行程數量"><a href="#pm-start-servers-初始行程數量" class="headerlink" title="pm.start_servers(初始行程數量)"></a>pm.start_servers(初始行程數量)</h2><p><code>pm.start_servers</code> 可設定 PHP-FPM 服務在一開始啟動時，要配置多少個行程</p>
<p><code>pm.start_servers</code> 同樣有一個計算公式可以參考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.start_servers &#x3D; min_spare_servers + (max_spare_servers - min_spare_servers) &#x2F; 2</span><br></pre></td></tr></table></figure>

<h2 id="pm-min-spare-servers-最小閒置行程數量"><a href="#pm-min-spare-servers-最小閒置行程數量" class="headerlink" title="pm.min_spare_servers(最小閒置行程數量)"></a>pm.min_spare_servers(最小閒置行程數量)</h2><p><code>pm.min_spare_servers</code> 設定 PHP-FPM 最小閒置行程的數量</p>
<h2 id="pm-max-spare-servers-最大閒置行程數量"><a href="#pm-max-spare-servers-最大閒置行程數量" class="headerlink" title="pm.max_spare_servers(最大閒置行程數量)"></a>pm.max_spare_servers(最大閒置行程數量)</h2><p><code>pm.max_spare_servers</code> 設定 PHP-FPM 最大閒置行程的數量</p>
<blockquote>
<p>這邊需要注意的是 <code>pm.max_spare_servers</code> 的值只能小於等於 <code>pm.max_children</code></p>
</blockquote>
<h2 id="pm-max-requests-單一行程可處理連線數"><a href="#pm-max-requests-單一行程可處理連線數" class="headerlink" title="pm.max_requests(單一行程可處理連線數)"></a>pm.max_requests(單一行程可處理連線數)</h2><p><code>pm.max_requests</code> 可設定單一 PHP-FPM 最多可以處理多少個連線，當一個行程處理的連線數達到設定值時，此行程會被 Kill 掉，而重新產生另一個新的行程</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://kejyuntw.gitbooks.io/ubuntu-learning-notes/content/web/php/web-php-max-children.html">https://kejyuntw.gitbooks.io/ubuntu-learning-notes/content/web/php/web-php-max-children.html</a></li>
<li><a href="https://support.plesk.com/hc/en-us/articles/360011988053-How-to-calculate-pm-max-children-value-">https://support.plesk.com/hc/en-us/articles/360011988053-How-to-calculate-pm-max-children-value-</a></li>
<li><a href="https://www.mdeditor.tw/pl/p9Vf/zh-tw">https://www.mdeditor.tw/pl/p9Vf/zh-tw</a></li>
</ul>
]]></content>
      <tags>
        <tag>PHP-FPM</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GitHub Pages</title>
    <url>/2021/05/03/%E4%BD%BF%E7%94%A8GitHub-Pages/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們開發程式時，一定都會想到 GitHub 或 GiLab 等版控的工具，今天要來介紹一下 GitHub Pages，GitHub Pages 是由 GitHub 所提供的服務，可以讓 Repository 內的靜態檔案，以網頁的方式呈現出來，這代表著 GitHub Pages 提供了 Web Server 的服務，但僅僅支援靜態頁面，如果是後端相關的 code，例如: .php 的副檔名，GitHub Pages 是不會有作用的，所以很多人會使用 GitHub Pages 來架設自己的部落格(Blog)。</p>
<span id="more"></span>

<h2 id="如何使用-GitHub-Pages"><a href="#如何使用-GitHub-Pages" class="headerlink" title="如何使用 GitHub Pages"></a>如何使用 GitHub Pages</h2><p>這邊假設大家對於 Git 的使用都已經熟悉了，在依據下面幾個步驟就可以完成 GitHub Pages</p>
<ul>
<li>新增專案(Repository)</li>
<li>建立測試檔</li>
<li>測試網頁功能</li>
</ul>
<h3 id="新增專案-Repository"><a href="#新增專案-Repository" class="headerlink" title="新增專案(Repository)"></a>新增專案(Repository)</h3><p>在專案名稱的地方，填寫「<code>username</code>.github.io」，這個 <code>username</code> 指的是自己的 GitHub 帳號。 並設定為 Public，不建立 README.md 的檔案，後續要新增測試檔案時再自己針對目錄做 Git Initial。</p>
<blockquote>
<p>要使用 GitHub Pages，Repository 需要設定為 Public</p>
</blockquote>
<p><img src="1.png"></p>
<h3 id="建立測試檔"><a href="#建立測試檔" class="headerlink" title="建立測試檔"></a>建立測試檔</h3><p>接下來，在本機建立一個目錄並進入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir username.github.io</span><br><span class="line">$ cd username.github.io</span><br></pre></td></tr></table></figure>

<p>並寫一個測試的首頁 index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello World&quot; &gt; index.html</span><br></pre></td></tr></table></figure>

<p>初始化目錄並設定 Rmote Repository</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git remote add origin git@github.com:username&#x2F;username.github.io.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述 username 請填入自己的 GitHub 帳號</p>
</blockquote>
<p>提交檔案並推上 GitHub</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add --all</span><br><span class="line">$ git commit -m &quot;Initial commit&quot;</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="測試網頁功能"><a href="#測試網頁功能" class="headerlink" title="測試網頁功能"></a>測試網頁功能</h3><p>成功推送後，可以開啟 https://<code>username</code>.github.io 試試看，會顯示「Hello World」</p>
<blockquote>
<p>測試的時候，可以的話盡量開啟無痕視窗來測試，這樣比較不會因為多次修改而造成 cache 的問題</p>
</blockquote>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://pages.github.com/">https://pages.github.com/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>GitHub Pages</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>在 K8s 使用 FTP</title>
    <url>/2021/04/26/%E5%9C%A8K8s%E4%BD%BF%E7%94%A8FTP/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期因公司內部的需求，需要在本機存取 K8s 內持久化儲存的檔案，原先想使用 NFS 架構來做掛載存取，但是因為這樣有點過於麻煩，後來才想使用 FTP 來實現，下面說明如何在 K8s 實現 FTP 功能，讓本機環境可以存取到持久化硬碟。</p>
<span id="more"></span>

<p>這邊實現的是 SFTP 使用 22 port 連線，存取認證方式可以是使用「金鑰」或是「帳號/密碼驗證」</p>
<p>這邊先簡單羅列步驟：</p>
<ol>
<li>產生 ssh 認證使用的金鑰</li>
<li>編寫 Dockerfile</li>
<li>編寫 K8s YAML 檔案</li>
<li>暴露一個 External LoadBalace</li>
<li>使用 FileZilla 測試</li>
</ol>
<blockquote>
<p>環境是使用 GKE(Google Kubernetes Engine)</p>
</blockquote>
<h2 id="產生-ssh-金鑰"><a href="#產生-ssh-金鑰" class="headerlink" title="產生 ssh 金鑰"></a>產生 ssh 金鑰</h2><p>產生 ssh 金鑰是為了讓後續連線時，可以使用金鑰作為驗證，這邊是使用 Mac 的終端機產生，指令參照以下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -f sftp_key</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Passphrase 設不設定都可以，如果有設定的話，最後以 FileZilla 測試時，private key 需要額外產生 .ppk 檔才能使用，後續會講解</p>
</blockquote>
<p>完成後，在你目前位置的目錄上會出現一對金鑰，一個為 public key 另一個為 private key</p>
<blockquote>
<p>一般來說，我們都會習慣把金鑰統一放置在本機家目錄底下的 .ssh 目錄內，如果自己有習慣的放置地方也可以放到自己習慣的位置</p>
</blockquote>
<h2 id="編寫-Dockerfile"><a href="#編寫-Dockerfile" class="headerlink" title="編寫 Dockerfile"></a>編寫 Dockerfile</h2><p>我們需要將 public key 放進映像檔中，這樣在連線時才有辦法做金鑰驗證。 要實現這方式有兩個：</p>
<ul>
<li>在 ftp 服務啟動時以 volume 方式掛載 public key 到相對位置</li>
<li>直接複製到映像檔內</li>
</ul>
<p>這邊採用的是第二種方式，編寫 Dockerfile 並將 public key 放進去，我們要將 public key 放到使用者家目錄底下的 <code>./.ssh/keys</code> 位置，所以我們需要建立相對應路徑，並將複製進去，可以參考以下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM atmoz&#x2F;sftp:alpine</span><br><span class="line"></span><br><span class="line">RUN mkdir -p &#x2F;home&#x2F;rd&#x2F;.ssh&#x2F;keys</span><br><span class="line">COPY .&#x2F;sftp_key.pub &#x2F;home&#x2F;rd&#x2F;.ssh&#x2F;keys&#x2F;</span><br></pre></td></tr></table></figure>

<p>這邊使用的 base image 是 atmoz/sftp:alpine，當然你也可以選擇其他版本(eg. debian…)。</p>
<p>最後進行 docker build 的動作，並上傳到存放區</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build --no-cache -t custom-sftp:alpine -f Dockerfile .</span><br></pre></td></tr></table></figure>

<h2 id="編寫-K8s-YAML-檔案"><a href="#編寫-K8s-YAML-檔案" class="headerlink" title="編寫 K8s YAML 檔案"></a>編寫 K8s YAML 檔案</h2><p>因為我們要運行在 GKE 上面，需要編寫 YAML 以便運行與後續管理，這邊是使用 Deployment 的 Object，以下只截取部片重要片段，其餘部分需要自行補齊</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: ftp</span><br><span class="line">  namespace: default</span><br><span class="line">...</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      containers:</span><br><span class="line">      - name: ftp</span><br><span class="line">        image: [修改為剛剛上傳的映像檔路徑]</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - containerPort: 22</span><br><span class="line">        args:</span><br><span class="line">          - rd::::upload</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - name: volume-test</span><br><span class="line">            mountPath: &#x2F;home&#x2F;rd&#x2F;upload&#x2F;test</span><br><span class="line">            subPath: upload-image</span><br><span class="line">      volumes:</span><br><span class="line">        - name: volume-test</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: mypvc</span><br></pre></td></tr></table></figure>

<h3 id="snippet-解析"><a href="#snippet-解析" class="headerlink" title="snippet 解析"></a>snippet 解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">args:</span><br><span class="line">  - rd::::upload</span><br></pre></td></tr></table></figure>

<p>啟動參數的意義，這邊是 <code>rd::::upload</code>，這表示使用者帳號為rd，並且在家目錄底下建立一個 upload 的目錄(<code>/home/rd/upload</code>)，以便做存取，這樣我們就能夠將持久化硬碟掛載到 <code>/home/rd/upload</code> 路徑底下。</p>
<blockquote>
<p>使用者帳號可以自訂，不一定要使用rd</p>
</blockquote>
<p>可以看到 rd 的帳號並沒有設定密碼，在沒有設定密碼的情況下，表示認證會使用金鑰認證，那如果要使用密碼驗證可以這樣表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rd:12345:::upload</span><br></pre></td></tr></table></figure>

<p>這樣表示密碼為 12345</p>
<h2 id="暴露一個-External-LoadBalace"><a href="#暴露一個-External-LoadBalace" class="headerlink" title="暴露一個 External LoadBalace"></a>暴露一個 External LoadBalace</h2><p>暴露外部 LB 這樣可以讓本機去存取到 GKE 內的服務，但是白名單記得要設定，以提高安全性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: ftp-proxy</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  loadBalancerIP: [填入自己的外網IP]</span><br><span class="line">  loadBalancerSourceRanges:</span><br><span class="line">  - [填入自己的白名單]</span><br><span class="line">  ports:</span><br><span class="line">    - name: ssh</span><br><span class="line">      port: 22</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: 22</span><br><span class="line">  selector:</span><br><span class="line">    app: ftp</span><br></pre></td></tr></table></figure>

<h3 id="snippet-解析-1"><a href="#snippet-解析-1" class="headerlink" title="snippet 解析"></a>snippet 解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ports:</span><br><span class="line">  - name: ssh</span><br><span class="line">    port: 22</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 22</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中這段 port 有沒有要改成其他非預設 22 port 都可以，以安全性角度來說可以做個修改，例如 <code>port: 14322</code>。 這樣連線時就使用 14322 做連線，GKE 就會自動做 port 的 mapping。</p>
<h2 id="使用-FileZilla-測試"><a href="#使用-FileZilla-測試" class="headerlink" title="使用 FileZilla 測試"></a>使用 FileZilla 測試</h2><p>最後我們可以下載 FileZilla Client 來測試，如果剛才編寫 Deployment 的 YAML 時，啟動參數有設定密碼的話，就可以直接填入相關資訊做連線測試了。</p>
<p>填入資訊</p>
<ul>
<li>主機: 填入External LoadBalance 的 IP</li>
<li>使用者名稱: 填入啟動參數設定的使用者</li>
<li>密碼: 填入啟動參數設定的密碼</li>
<li>連接埠: 預設是22，如果剛剛在編寫 External LoadBalace 時，有修改 port，這邊記得要跟著變</li>
</ul>
<p>如果是使用金鑰驗證，我們要先設定好 private key 的位置，開啟 FileZilla Client，依照下圖點選到設定位置</p>
<p>點選 編輯 &gt; 設定</p>
<p><img src="0.png"></p>
<p>選擇 SFTP 並點選「加入金鑰檔案」，此時會請你選擇 private key 的位置</p>
<p><img src="1.png"></p>
<p>這邊要注意一下，如果一開始產生金鑰時有設定 passphrase，會跳出此視窗，主要是因為他需要將 .key 轉成 .ppk，這邊直接點「是」</p>
<p><img src="2.png"></p>
<p>輸入設定的 passphrase</p>
<p><img src="3.png"></p>
<p>選擇鑰儲存 .ppk 的位置與命名</p>
<p><img src="4.png"></p>
<p>最後再回到主畫面將連線資訊填入，密碼不用填寫，當連線後，會請你輸入 passphrase 的密碼</p>
]]></content>
      <tags>
        <tag>GKE</tag>
        <tag>GCP</tag>
        <tag>K8s</tag>
        <tag>Google Cloud Platform</tag>
        <tag>Kubernetes</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
</search>
