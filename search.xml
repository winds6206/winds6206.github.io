<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在 Docker Engine 使用 Cloud SQL Auth Proxy</title>
    <url>/posts/8ebcb883/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因為之前的 <a href="https://blog.tonyjhang.dev/posts/3850bdf7/">透過 Auth Proxy 存取 Cloud SQL</a> 的篇幅有點長，所以決定把 Docker Engine 使用 Cloud SQL Auth Proxy 的方法另外寫一篇，在看這篇之前，如果還沒有閱讀過上一篇，可以點擊上面連結，先去看看，再回過頭來接續</p>
<span id="more"></span>

<h2 id="Cloud-SQL-Auth-Proxy-in-a-Docker-container"><a href="#Cloud-SQL-Auth-Proxy-in-a-Docker-container" class="headerlink" title="Cloud SQL Auth Proxy in a Docker container"></a>Cloud SQL Auth Proxy in a Docker container</h2><p>建立 Google Service Account</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts create gsa-cloud-sql \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>並且賦予權限，以下三個 IAM 權限任一皆可</p>
<ul>
<li>roles/cloudsql.client</li>
<li>roles/cloudsql.editor</li>
<li>roles/cloudsql.admin</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud projects add-iam-policy-binding demo-123 \</span><br><span class="line">    --member <span class="string">&quot;serviceAccount:gsa-cloud-sql@demo-123.iam.gserviceaccount.com&quot;</span> \</span><br><span class="line">    --role <span class="string">&quot;roles/cloudsql.client&quot;</span> \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>記得把 Google Service Account 的 JWT 下載到本機</p>
<p>將 JWT 與連線資訊掛載到 container 內，讓容器拿著這把 Key 到 GCP 上做授權驗證</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Syntax</span></span><br><span class="line">docker run -d \</span><br><span class="line">  -v [LOCAL_PATH_TO_KEY_FILE]:/path/to/service-account-key.json \</span><br><span class="line">  -p 127.0.0.1:3306:3306 \</span><br><span class="line">  gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.13.0 \</span><br><span class="line">  --credentials-file /path/to/service-account-key.json \</span><br><span class="line">  --port=3306 \</span><br><span class="line">  --address=0.0.0.0 \</span><br><span class="line">  --structured-logs \</span><br><span class="line">  --debug-logs \</span><br><span class="line">  [INSTANCE_CONNECTION_NAME]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Eample</span></span><br><span class="line">sudo docker run -d \</span><br><span class="line">  -v /home/tony/key.json:/path/to/service-account-key.json \</span><br><span class="line">  -p 127.0.0.1:3306:3306 \</span><br><span class="line">  gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.13.0 \</span><br><span class="line">  --credentials-file /path/to/service-account-key.json \</span><br><span class="line">  --port=3306 \</span><br><span class="line">  --address=0.0.0.0 \</span><br><span class="line">  --structured-logs \</span><br><span class="line">  --debug-logs \</span><br><span class="line">  demo-123:asia-east1:<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>關於 <code>-p 127.0.0.1:3306:3306</code>，如果是要讓 Docker 環境內其他 container 可以存取，需要將 <code>127.0.0.1</code> 調整為 <code>0.0.0.0</code>，或者直接省略，如：<code>-p 3306:3306</code>，因為預設就是 <code>0.0.0.0</code></p>
<blockquote>
<p>Always specify 127.0.0.1 prefix in -p so that the Cloud SQL Auth proxy is not exposed outside the local host. The “0.0.0.0” in the instances parameter is required to make the port accessible from outside of the Docker container.</p>
</blockquote>
<p>連線名稱(connectionName) 的查詢方式，或者直接到網頁看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line">gcloud sql instances describe [Instance_Name] --project=[Project_ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">gcloud sql instances describe <span class="built_in">test</span> --project=demo-123</span><br></pre></td></tr></table></figure>

<p>最後使用 Cloud SQL 的使用者帳號與 Cloud SQL Auth Proxy 做連線驗證，也可以使用第三方工具來連線測試，例如：MySQL WorkBench, phpMyAdmin…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u [USERNAME] -p --host 127.0.0.1</span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://cloud.google.com/sql/docs/mysql/connect-auth-proxy">https://cloud.google.com/sql/docs/mysql/connect-auth-proxy</a></li>
</ul>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>Cloud SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 Auth Proxy 存取 Cloud SQL</title>
    <url>/posts/3850bdf7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般來說，要連線到 Could SQL 需要透過 Proxy 與 GCP 做授權驗證，而該代理工具稱為「Cloud SQL Auth Proxy」</p>
<p>Cloud SQL Auth Proxy 是存取 Could SQL 的連線工具，讓我們無須額外設定網路授權或 SSL 的相關設定，提供較安全的存取方式。</p>
<span id="more"></span>

<p>使用 Cloud SQL Auth Proxy 的好處大致有三點：</p>
<ul>
<li>安全的加密連線</li>
<li>透過 IAM 的簡易連線授權</li>
<li>自動更新 OAuth 2.0 Token</li>
</ul>
<p>有興趣深入了解，可以參考<a href="https://cloud.google.com/sql/docs/mysql/sql-proxy">官方文件</a></p>
<h2 id="大致設定流程"><a href="#大致設定流程" class="headerlink" title="大致設定流程"></a>大致設定流程</h2><p>大前提：</p>
<ul>
<li>Google Service Account 簡稱 GSA</li>
<li>Kubernetes Service Account 簡稱 KSA</li>
<li>Project ID 為 demo-123</li>
<li>Cloud SQL 使用的是 MySQL</li>
</ul>
<p>使用 Google Service Account/E-mail 加上 Cloud SQL Auth Proxy 來做授權驗證，簡單來說，就是透過 Google Service Account/E-mail 的 IAM 權限管控，來決定使用者是否能夠存取到 Cloud SQL 的服務，接著再使用 Cloud SQL 裡面的使用者帳號與 SQL 做連線操作。</p>
<p>主要設定步驟如下</p>
<ol>
<li>創建 Google Service Account 並賦予 IAM 權限 → roles/cloudsql.client</li>
</ol>
<p>以下三個 IAM 權限任一皆可</p>
<ul>
<li>roles/cloudsql.client</li>
<li>roles/cloudsql.editor</li>
<li>roles/cloudsql.admin</li>
</ul>
<ol start="2">
<li>下載 Google Service Account 的 JWT</li>
<li>將 JWT 交付給 Cloud SQL Auth Proxy 做授權驗證</li>
<li>使用 Cloud SQL 的使用者帳號與 Cloud SQL Auth Proxy 做連線</li>
</ol>
<h2 id="本機使用-Cloud-SQL-Auth-Proxy"><a href="#本機使用-Cloud-SQL-Auth-Proxy" class="headerlink" title="本機使用 Cloud SQL Auth Proxy"></a>本機使用 Cloud SQL Auth Proxy</h2><p>這種方式是透過 Auth Proxy 與 Cloud SQL 建立起一個 Tunnel，本機就可以直接與 Auth Proxy 連線存取到 Cloud SQL</p>
<p>有兩種方式可以達到目的</p>
<ul>
<li>使用 Google Service Account</li>
<li>使用 E-mail</li>
</ul>
<h3 id="方法一：使用-Service-Account"><a href="#方法一：使用-Service-Account" class="headerlink" title="方法一：使用 Service Account"></a>方法一：使用 Service Account</h3><p>下載相對應作業系統的 Cloud SQL Auth Proxy，並按照官方的方式修改權限</p>
<p><a href="https://cloud.google.com/sql/docs/mysql/connect-admin-proxy#cloud-sql-auth-proxy-docker-image_1">https://cloud.google.com/sql/docs/mysql/connect-admin-proxy#cloud-sql-auth-proxy-docker-image_1</a></p>
<p>建立 Google Service Account</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts create gsa-cloud-sql \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>並且賦予權限</p>
<blockquote>
<p>IAM 權限請參考前一節</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud projects add-iam-policy-binding demo-123 \</span><br><span class="line">    --member <span class="string">&quot;serviceAccount:gsa-cloud-sql@demo-123.iam.gserviceaccount.com&quot;</span> \</span><br><span class="line">    --role <span class="string">&quot;roles/cloudsql.client&quot;</span> \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>記得把 Google Service Account 的 JWT 下載到本機</p>
<p>使用 TCP Socket 的方式啟用 Cloud SQL Auth Proxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2024/08/28 Updated</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Syntax</span></span><br><span class="line">./cloud-sql-proxy --address 0.0.0.0 \</span><br><span class="line">  --port 3306 \</span><br><span class="line">  --structured-logs \</span><br><span class="line">  --debug-logs \</span><br><span class="line">  --credentials-file [PATH_TO_KEY_FILE] \</span><br><span class="line">  [INSTANCE_CONNECTION_NAME]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">./cloud-sql-proxy --address 0.0.0.0 \</span><br><span class="line">  --port 3306 \</span><br><span class="line">  --structured-logs \</span><br><span class="line">  --debug-logs \</span><br><span class="line">  --credentials-file /path/to/service-account-key.json \</span><br><span class="line">  demo-123:asia-east1:<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>連線名稱(connectionName) 的查詢方式，或者直接到網頁看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Format</span></span><br><span class="line">gcloud sql instances describe [Instance_Name] --project=[Project_ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">gcloud sql instances describe <span class="built_in">test</span> --project=demo-123</span><br></pre></td></tr></table></figure>

<p>最後使用 Cloud SQL 的使用者帳號與 Cloud SQL Auth Proxy 做連線驗證，也可以使用第三方工具來連線測試，例如：MySQL WorkBench, phpMyAdmin…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u [USERNAME] -p --host 127.0.0.1</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用-E-mail"><a href="#方法二：使用-E-mail" class="headerlink" title="方法二：使用 E-mail"></a>方法二：使用 E-mail</h3><p>改成使用自己的 E-mail 帳號賦予的 IAM 權限來做授權驗證，確認此帳號是否有存取 cloudSQL 的權限，所以<strong>在 proxy 在與 GCP 做授權驗證前，我們必須手動使用 Cloud SDK 來登入 Google Cloud 並透過瀏覽器來確認 Cloud Identity credentials</strong>，但是一般來說本機都已經有做過此動過了</p>
<blockquote>
<p>uses the Cloud SDK to log in to Google Cloud and enters his Cloud Identity credentials through the web browser.</p>
</blockquote>
<p>如果還未執行 Cloud Identity credentials，可以使用下面指令，這部份就不多做說明，當作大家都已經知道如何登入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud auth login</span><br></pre></td></tr></table></figure>

<p>將自己的 E-mail 帳號新增 IAM 權限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud projects add-iam-policy-binding demo-123 \</span><br><span class="line">    --member <span class="string">&quot;user:tony@gmail.com&quot;</span> \</span><br><span class="line">    --role <span class="string">&quot;roles/cloudsql.client&quot;</span> \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>產生應用程式使用的 credential，下了該指令後，會有網頁流程要跑，其實就是把你的 E-mail 的權限做成 json 檔，然後 Proxy 程式預設會去拿這支檔案來用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud auth application-default login</span><br></pre></td></tr></table></figure>

<p>這將會在 <code>$&#123;HOME&#125;/.config/gcloud</code> 產生一個 json 檔 「application_default_credentials.json」，如要撤銷可以使用 <code>gcloud auth application-default revoke</code>，此時檔案將會被移除並撤銷</p>
<p>接著直接在本機使用下面指令，可以發現這次的指令是不需要 <code>--credentials-file</code>，因為我們需要讓系統自動到 <code>$&#123;HOME&#125;/.config/gcloud</code> 取得授權驗證</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2024/08/28 Updated</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Syntax</span></span><br><span class="line">./cloud-sql-proxy --address 0.0.0.0 \</span><br><span class="line">  --port 3306 \</span><br><span class="line">  --structured-logs \</span><br><span class="line">  --debug-logs \</span><br><span class="line">  --credentials-file [PATH_TO_KEY_FILE] \</span><br><span class="line">  [INSTANCE_CONNECTION_NAME]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">./cloud-sql-proxy --address 0.0.0.0 \</span><br><span class="line">  --port 3306 \</span><br><span class="line">  --structured-logs \</span><br><span class="line">  --debug-logs \</span><br><span class="line">  --credentials-file <span class="variable">$&#123;HOME&#125;</span>/.config/gcloud/application_default_credentials.json \</span><br><span class="line">  demo-123:asia-east1:<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="Cloud-SQL-Auth-Proxy-in-K8s"><a href="#Cloud-SQL-Auth-Proxy-in-K8s" class="headerlink" title="Cloud SQL Auth Proxy in K8s"></a>Cloud SQL Auth Proxy in K8s</h2><p>在 GKE 內的 Pod 若是要存取 Cloud SQL，一樣是透過 Cloud SQL Auth Proxy 來做代理的動作，官方建議將 Auth Proxy 以 sidecar 的形式運行在需要使用的 Pod 上，並且依照不同服務給予不同的  Google Service Account，當然如果有特殊理由，也是可以多個 Pod 使用同一個 Cloud SQL Auth Proxy 進行存取。</p>
<p>在 GKE 中使用 Google Service Account，原廠已經建議使用 Workload-Identity 的方式進行綁定，不建議再將 JWT 下載後以 Secret 方式掛載，對於還不知道 GKE Workload-Identity 或者想更進一步了解使用方式的，可以參考我的<a href="https://blog.tonyjhang.dev/posts/7d4918c/#more">另外一篇</a>，裡面有更詳細的介紹。</p>
<p>Google Service Account 的設定，前面已經有步驟，這邊不再重複贅述，直接從 Workload-Identity 中 KSA 和 GSA 綁定步驟開始</p>
<p>建立 K8s ServiceAccount</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ksa-cloud-sql-proxy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">iam.gke.io/gcp-service-account:</span> <span class="string">gsa-cloud-sql-proxy@demo-123.iam.gserviceaccount.com</span></span><br></pre></td></tr></table></figure>

<p>將 KSA(ksa-cloud-sql-proxy) 與 GSA(gsa-cloud-sql-proxy) 進行綁定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts add-iam-policy-binding gsa-cloud-sql-proxy@demo-123.iam.gserviceaccount.com \</span><br><span class="line">    --role roles/iam.workloadIdentityUser \</span><br><span class="line">    --member <span class="string">&quot;serviceAccount:demo-123.svc.id.goog[default/ksa-cloud-sql-proxy]&quot;</span> \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>佈署 Cloud SQL Auth Proxy，這邊沒有以 sidecar 方式呈現，如果要以 sidecar 運行的話，可以再自己加以修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">    <span class="attr">product:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">    <span class="attr">product:</span> <span class="string">demo</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">    <span class="attr">product:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">      <span class="attr">product:</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">        <span class="attr">product:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">ksa-cloud-sql-proxy</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cloud-sql-proxy</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.13</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;--private-ip&quot;</span>  <span class="comment"># 使用私人叢集需要打開</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;--structured-logs&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;--port=3306&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;--address=0.0.0.0&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;--debug-logs&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;demo-123:asia-east1:test&quot;</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TZ</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">Asia/Taipei</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">iam.gke.io/gke-metadata-server-enabled:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>最後用 phpMyAdmin 測試連線情況</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">phpmyadmin</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">phpmyadmin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">phpmyadmin</span></span><br><span class="line">      <span class="attr">repo:</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">phpmyadmin</span></span><br><span class="line">        <span class="attr">repo:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PMA_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">cloud-sql-proxy.default.svc.cluster.local</span> <span class="comment"># 填入 cloud-sql-proxy 的 service </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PMA_PORT</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;3306&quot;</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">phpmyadmin:5.1.1</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">phpmyadmin</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>如果對於 GKE 上使用 Workload-Identity 不懂的，不妨先去<a href="https://blog.tonyjhang.dev/posts/7d4918c/#more">補一下</a></p>
<p>官方文件在掛載 KSA 的 deployment 描述檔有加上 <code>spec.nodeSelector</code>，來確保服務正常跑在有啟用 Workload-Identity 的 Node 上</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">iam.gke.io/gke-metadata-server-enabled:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://cloud.google.com/sql/docs/mysql/connect-auth-proxy">https://cloud.google.com/sql/docs/mysql/connect-auth-proxy</a></li>
<li><a href="https://cloud.google.com/sql/docs/mysql/sql-proxy#benefits_of_the">https://cloud.google.com/sql/docs/mysql/sql-proxy#benefits_of_the</a></li>
<li><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity">https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity</a></li>
</ul>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>Cloud SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Auto Completion不區分大小寫</title>
    <url>/posts/3bc3c62d/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Bash Completion 可以讓你在使用 Bash 指令時，按「Tab」鍵，讓系統自動幫你把指令補齊，這可以加速你在輸入指令時的速度。</p>
<p>但如果今天我想要進入 Test 的目錄，依照習慣預設輸入法會是小寫所以大部的人會輸入成</p>
<ul>
<li>輸入 <code>cd t</code> 再按 Tab 鍵</li>
</ul>
<p>此時系統就無法幫忙補齊，因為預設會區分大小寫，如果要忽略大小寫可以參考以下方式</p>
<span id="more"></span>

<h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><p>在家目錄底下有個 <code>.inputrc</code> 的檔案，可以最後面補上 <code>set completion-ignore-case On</code> 即可。 或者直接輸入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;set completion-ignore-case On&#x27;</span> &gt;&gt; ~/.inputrc</span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://caloskao.org/linux-make-tab-auto-completion-case-insensitive-in-the-terminal/">https://caloskao.org/linux-make-tab-auto-completion-case-insensitive-in-the-terminal/</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>在 K8s 使用 FTP</title>
    <url>/posts/2de962d3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期因公司內部的需求，需要在本機存取 K8s 內持久化儲存的檔案，原先想使用 NFS 架構來做掛載存取，但是因為這樣有點過於麻煩，後來才想使用 FTP 來實現，下面說明如何在 K8s 實現 FTP 功能，讓本機環境可以存取到持久化硬碟。</p>
<span id="more"></span>

<p>這邊實現的是 SFTP 使用 22 port 連線，存取認證方式可以是使用「金鑰」或是「帳號/密碼驗證」</p>
<p>這邊先簡單羅列步驟：</p>
<ol>
<li>產生 ssh 認證使用的金鑰</li>
<li>編寫 Dockerfile</li>
<li>編寫 K8s YAML 檔案</li>
<li>暴露一個 External LoadBalace</li>
<li>使用 FileZilla 測試</li>
</ol>
<blockquote>
<p>環境是使用 GKE(Google Kubernetes Engine)</p>
</blockquote>
<h2 id="產生-ssh-金鑰"><a href="#產生-ssh-金鑰" class="headerlink" title="產生 ssh 金鑰"></a>產生 ssh 金鑰</h2><p>產生 ssh 金鑰是為了讓後續連線時，可以使用金鑰作為驗證，這邊是使用 Mac 的終端機產生，指令參照以下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -f sftp_key</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Passphrase 設不設定都可以，如果有設定的話，最後以 FileZilla 測試時，private key 需要額外產生 .ppk 檔才能使用，後續會講解</p>
</blockquote>
<p>完成後，在你目前位置的目錄上會出現一對金鑰，一個為 public key 另一個為 private key</p>
<blockquote>
<p>一般來說，我們都會習慣把金鑰統一放置在本機家目錄底下的 .ssh 目錄內，如果自己有習慣的放置地方也可以放到自己習慣的位置</p>
</blockquote>
<h2 id="編寫-Dockerfile"><a href="#編寫-Dockerfile" class="headerlink" title="編寫 Dockerfile"></a>編寫 Dockerfile</h2><p>我們需要將 public key 放進映像檔中，這樣在連線時才有辦法做金鑰驗證。 要實現這方式有兩個：</p>
<ul>
<li>在 ftp 服務啟動時以 volume 方式掛載 public key 到相對位置</li>
<li>直接複製到映像檔內</li>
</ul>
<p>這邊採用的是第二種方式，編寫 Dockerfile 並將 public key 放進去，我們要將 public key 放到使用者家目錄底下的 <code>./.ssh/keys</code> 位置，所以我們需要建立相對應路徑，並將複製進去，可以參考以下</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> atmoz/sftp:alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /home/rd/.ssh/keys</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./sftp_key.pub /home/rd/.ssh/keys/</span></span><br></pre></td></tr></table></figure>

<p>這邊使用的 base image 是 atmoz/sftp:alpine，當然你也可以選擇其他版本(eg. debian…)。</p>
<p>最後進行 docker build 的動作，並上傳到存放區</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build --no-cache -t custom-sftp:alpine -f Dockerfile .</span><br></pre></td></tr></table></figure>

<h2 id="編寫-K8s-YAML-檔案"><a href="#編寫-K8s-YAML-檔案" class="headerlink" title="編寫 K8s YAML 檔案"></a>編寫 K8s YAML 檔案</h2><p>因為我們要運行在 GKE 上面，需要編寫 YAML 以便運行與後續管理，這邊是使用 Deployment 的 Object，以下只截取部片重要片段，其餘部分需要自行補齊</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ftp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ftp</span></span><br><span class="line">        <span class="attr">image:</span> [<span class="string">修改為剛剛上傳的映像檔路徑</span>]</span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">22</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">rd::::upload</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume-test</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/home/rd/upload/test</span></span><br><span class="line">            <span class="attr">subPath:</span> <span class="string">upload-image</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume-test</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">mypvc</span></span><br></pre></td></tr></table></figure>

<h3 id="snippet-解析"><a href="#snippet-解析" class="headerlink" title="snippet 解析"></a>snippet 解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">args:</span><br><span class="line">  - rd::::upload</span><br></pre></td></tr></table></figure>

<p>啟動參數的意義，這邊是 <code>rd::::upload</code>，這表示使用者帳號為rd，並且在家目錄底下建立一個 upload 的目錄(<code>/home/rd/upload</code>)，以便做存取，這樣我們就能夠將持久化硬碟掛載到 <code>/home/rd/upload</code> 路徑底下。</p>
<blockquote>
<p>使用者帳號可以自訂，不一定要使用rd</p>
</blockquote>
<p>可以看到 rd 的帳號並沒有設定密碼，在沒有設定密碼的情況下，表示認證會使用金鑰認證，那如果要使用密碼驗證可以這樣表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rd:12345:::upload</span><br></pre></td></tr></table></figure>

<p>這樣表示密碼為 12345</p>
<h2 id="暴露一個-External-LoadBalace"><a href="#暴露一個-External-LoadBalace" class="headerlink" title="暴露一個 External LoadBalace"></a>暴露一個 External LoadBalace</h2><p>暴露外部 LB 這樣可以讓本機去存取到 GKE 內的服務，但是白名單記得要設定，以提高安全性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ftp-proxy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">loadBalancerIP:</span> [<span class="string">填入自己的外網IP</span>]</span><br><span class="line">  <span class="attr">loadBalancerSourceRanges:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">填入自己的白名單</span>]</span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">22</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">22</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">ftp</span></span><br></pre></td></tr></table></figure>

<h3 id="snippet-解析-1"><a href="#snippet-解析-1" class="headerlink" title="snippet 解析"></a>snippet 解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ports:</span><br><span class="line">  - name: ssh</span><br><span class="line">    port: 22</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 22</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中這段 port 有沒有要改成其他非預設 22 port 都可以，以安全性角度來說可以做個修改，例如 <code>port: 14322</code>。 這樣連線時就使用 14322 做連線，GKE 就會自動做 port 的 mapping。</p>
<h2 id="使用-FileZilla-測試"><a href="#使用-FileZilla-測試" class="headerlink" title="使用 FileZilla 測試"></a>使用 FileZilla 測試</h2><p>最後我們可以下載 FileZilla Client 來測試，如果剛才編寫 Deployment 的 YAML 時，啟動參數有設定密碼的話，就可以直接填入相關資訊做連線測試了。</p>
<p>填入資訊</p>
<ul>
<li>主機: 填入External LoadBalance 的 IP</li>
<li>使用者名稱: 填入啟動參數設定的使用者</li>
<li>密碼: 填入啟動參數設定的密碼</li>
<li>連接埠: 預設是22，如果剛剛在編寫 External LoadBalace 時，有修改 port，這邊記得要跟著變</li>
</ul>
<p>如果是使用金鑰驗證，我們要先設定好 private key 的位置，開啟 FileZilla Client，依照下圖點選到設定位置</p>
<p>點選 編輯 → 設定</p>
<p><img src="mk-20240119114134.png"></p>
<p>選擇 SFTP 並點選「加入金鑰檔案」，此時會請你選擇 private key 的位置</p>
<p><img src="mk-20240119114200.png"></p>
<p>這邊要注意一下，如果一開始產生金鑰時有設定 passphrase，會跳出此視窗，主要是因為他需要將 .key 轉成 .ppk，這邊直接點「是」</p>
<p><img src="mk-20240119114218.png"></p>
<p>輸入設定的 passphrase</p>
<p><img src="mk-20240119114239.png"></p>
<p>選擇鑰儲存 .ppk 的位置與命名</p>
<p><img src="mk-20240119114300.png"></p>
<p>最後再回到主畫面將連線資訊填入，密碼不用填寫，當連線後，會請你輸入 passphrase 的密碼</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Cloud NAT的限制</title>
    <url>/posts/b9db6e7a/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因公司產品是採用 GKE 的基礎設施，為了讓 GKE 對外有一個 static IP，所以有加上 Cloud NAT 的功能，一開始加上去並沒有什麼問題，但日子長了之後，某一天發現要再擴增 Node 時，沒有辦法順利擴增，查了好一段時間才知道，原來是 Cloud NAT 導致要擴增 Node 時沒有辦法擴增，這其實很難想像得到，因為基本上不會有理由去懷疑是 Cloud NAT 所致。</p>
<p>所以這邊紀錄一下遇到的問題，說不定你也正遇到跟我一樣的問題</p>
<span id="more"></span>

<h2 id="Cloud-NAT"><a href="#Cloud-NAT" class="headerlink" title="Cloud NAT"></a>Cloud NAT</h2><p>在 Cloud NAT 的進階設定中，有一個欄位叫做「每個 VM<br>執行個體的最低通訊埠數量」，如果你是使用英文介面會顯示「Minimum ports per VM instance」，就是這個數值會去影響可以運行的機器數量，後來參考外國的一篇文章才了解到此設定的重要性(參考的資料放在文後)，此數值不僅會決定你所選取的 VPC 內可以使用的機器數量，還會決定你的每台機器從 NAT 出去的連線數量，以下詳細說明</p>
<h3 id="連線量"><a href="#連線量" class="headerlink" title="連線量"></a>連線量</h3><p>「每個 VM 執行個體的最低通訊埠數量」所填入的數值，本質意義是在說明: 你指定的 VPC 底下的每一台機器透過 Cloud NAT 到相同目的 IP 與 port 且使用相同的通訊協定(TCP or UDP) 的連線數量。</p>
<p>舉例來說：預設數值為64，我的 VPC 內有三台機器，其中一台機器連線到 <code>TCP 1.1.1.1:1000</code> 此目的的數量有64條，這時此台機器要再連線此目的的連線就會被 drop 掉，導致後續的連線會異常，但是還是可以連線到「其他目的」。</p>
<blockquote>
<p>此處的「其他目的」是指與 <code>TCP 1.1.1.1:1000</code> 不同的「目的IP」或「目的Port」或「通訊協定」</p>
</blockquote>
<p>以下都是可以正常連線的目的，而且連線數是個別分開計算，這樣舉例會比較清楚</p>
<ul>
<li>UDP 1.1.1.1:1000</li>
<li>TCP 2.2.2.2:1000</li>
<li>UDP 2.2.2.2:1000</li>
<li>TCP 2.2.2.2:2000</li>
<li>UDP 2.2.2.2:3000</li>
</ul>
<h3 id="機器數量"><a href="#機器數量" class="headerlink" title="機器數量"></a>機器數量</h3><p>再來要討論「每個 VM 執行個體的最低通訊埠數量」的數值要怎麼計算 VPC 底下可以開幾台 Node</p>
<p>每個 Cloud NAT 的 IP 有 65536 個連接埠分別給 TCP 與 UDP 使用，其中有 1024 個是公認通訊埠號(well-known port numbers)，所以實際可使用的連接埠為 64512(65536-1024)，如果使用 Google 給的預設數值64，那每個 NAT IP 可以支援相對應 VPC 底下高達 1008 台 Node (64512/64)，但是缺點就是可乘載的連線數量相對就比較少，如果想要擴增可乘載的機器數量，可以增加 NAT IP 來解決，如果在 Cloud NAT 放上第二組 NAT IP，此時 Node 就可以到 2016(1008*2) 那麼多。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://medium.com/bluekiri/high-availability-nat-gateway-at-google-cloud-platform-with-cloud-nat-8a792b1c4cc4">https://medium.com/bluekiri/high-availability-nat-gateway-at-google-cloud-platform-with-cloud-nat-8a792b1c4cc4</a></li>
</ul>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>Cloud NAT</tag>
      </tags>
  </entry>
  <entry>
    <title>GKE 上使用 Workload Identity</title>
    <url>/posts/7d4918c/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前在 GKE 內的應用程式若是有需要存取其他 GCP 上的服務時，會需要建立一個專用的 Service Account 並且將該帳戶賦予對應的權限，再將 JWT 掛載到應用程式。</p>
<p>這對於管理與資安上都是一大的隱憂，只要 JWT 不小心被有心人士拿到，就可以有相對應的權限。</p>
<span id="more"></span>

<p>而 GKE 上 Workload Identity 就是用來解決 JWT 需要下載使用的問題，只要 JWT 不外流，對於安全性就更上一層樓了。 只需要 kubernetes service account(簡稱 KSA) 與 google service account(簡稱 GSA) 進行綁定，再將 KSA 賦予給 Pod，應用程式就會有相對應的權限可以使用。</p>
<p>使用 Workload Identity 也是 Google 比較建議用來連接 GSA 的方式</p>
<blockquote>
<p>Workload Identity is the recommended way for your workloads running on Google Kubernetes Engine (GKE) to access Google Cloud services in a secure and manageable way.</p>
</blockquote>
<h2 id="啟用-Workload-Identity"><a href="#啟用-Workload-Identity" class="headerlink" title="啟用 Workload Identity"></a>啟用 Workload Identity</h2><p>要使用 Workload Identity，那就必須要先讓 GKE 支援 Workload Identity，可以從 Master Node 去確認有沒有啟用</p>
<p><img src="mk-20240118163311.png"></p>
<p>如果一開始建立叢集時沒有預先啟動，那麼之後要啟動的話，所以有的 Worker Node 都必須重新生成過一遍才會生效，這點需要注意。</p>
<p>Google 是建議啟用 Workload Identity 後，直接重新 create 新的 node pool</p>
<blockquote>
<p>We recommend creating new node pools if you also need to modify your applications to be compatible with Workload Identity.</p>
</blockquote>
<h2 id="確認自身權限"><a href="#確認自身權限" class="headerlink" title="確認自身權限"></a>確認自身權限</h2><p>先確認自身操作權限是否有以下兩個：</p>
<ul>
<li>roles/container.admin (Kubernetes Engine 管理員)</li>
<li>roles/iam.serviceAccountAdmin (服務帳戶管理員)</li>
</ul>
<h2 id="讓-Application-使用-Workload-Identity"><a href="#讓-Application-使用-Workload-Identity" class="headerlink" title="讓 Application 使用 Workload Identity"></a>讓 Application 使用 Workload Identity</h2><p>溫馨小提醒：</p>
<ol>
<li>這邊的 Project ID 統一用 demo-123</li>
<li>以下示範建議搭配<a href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity">官方文件</a>的指令服用，這樣會比較清楚各欄位要填什麼</li>
<li>如果熟練的話也可自行將部份指令轉成描述檔(YAML)</li>
</ol>
<p>建立測試用 Namespace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create namespace workload-identity</span><br></pre></td></tr></table></figure>

<p>建立測試用 kubernetes service account 在 workload-identity Namespace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount ksa-workload-identity \</span><br><span class="line">    --namespace workload-identity</span><br></pre></td></tr></table></figure>

<p>建立測試用 google service account</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts create gsa-workload-identity \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>賦予測試的 GSA 一個權限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud projects add-iam-policy-binding demo-123 \</span><br><span class="line">    --member <span class="string">&quot;serviceAccount:gsa-workload-identity@demo-123.iam.gserviceaccount.com&quot;</span> \</span><br><span class="line">    --role <span class="string">&quot;roles/cloudbuild.builds.viewer&quot;</span> \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>將 KSA(ksa-workload-identity) 與 GSA(gsa-workload-identity) 進行綁定，有兩種方式：</p>
<ul>
<li>使用 Google SDK</li>
<li>使用 K8s 描述檔：管理上較方便</li>
</ul>
<p><strong>使用 Google SDK</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts add-iam-policy-binding gsa-workload-identity@demo-123.iam.gserviceaccount.com \</span><br><span class="line">    --role roles/iam.workloadIdentityUser \</span><br><span class="line">    --member <span class="string">&quot;serviceAccount:demo-123.svc.id.goog[workload-identity/ksa-workload-identity]&quot;</span> \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>解除綁定的方式 <code>add-iam-policy-binding</code> 改成 <code>remove-iam-policy-binding</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts remove-iam-policy-binding gsa-workload-identity@demo-123.iam.gserviceaccount.com \</span><br><span class="line">    --role roles/iam.workloadIdentityUser \</span><br><span class="line">    --member <span class="string">&quot;serviceAccount:demo-123.svc.id.goog[workload-identity/ksa-workload-identity]&quot;</span> \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p>查詢 GSA 綁定哪個 KSA</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcloud iam service-accounts get-iam-policy gsa-workload-identity@demo-123.iam.gserviceaccount.com \</span><br><span class="line">    --project=demo-123</span><br></pre></td></tr></table></figure>

<p><strong>使用 K8s 描述檔</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">iam.cnrm.cloud.google.com/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IAMPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">iampolicy-workload-identity-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">resourceRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">iam.cnrm.cloud.google.com/v1beta1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">IAMServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gsa-workload-identity</span></span><br><span class="line">  <span class="attr">bindings:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">roles/iam.workloadIdentityUser</span></span><br><span class="line">      <span class="attr">members:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">serviceAccount:demo-123.svc.id.goog[workload-identity/ksa-workload-identity]</span></span><br></pre></td></tr></table></figure>

<p>調整 KSA 的設定，新增 annotation 資訊</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl annotate serviceaccount ksa-workload-identity \</span><br><span class="line">    --namespace workload-identity \</span><br><span class="line">    iam.gke.io/gcp-service-account=gsa-workload-identity@demo-123.iam.gserviceaccount.com</span><br></pre></td></tr></table></figure>

<p>前面一開始只是先建立 KSA，上方又在多新增 annotations，所以寫成描述檔會是下面這樣</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="string">iam.gke.io/gcp-service-account=gsa-workload-identity@demo-123.iam.gserviceaccount.com</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ksa-workload-identity</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">workload-identity</span></span><br></pre></td></tr></table></figure>

<p>功能驗證的話有兩種，一種是直接將目標應用程式加上相關設定去測試，另外一種是 Google 提供的簡易測試，如下</p>
<h3 id="Application-功能驗證"><a href="#Application-功能驗證" class="headerlink" title="Application 功能驗證"></a>Application 功能驗證</h3><p>在 Pod 或 Deployment 的描述檔新增以下片段，以便賦予 KSA，此時該應用服務就可以有相對應的 IAM 權限</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">ksa-workload-identity</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">iam.gke.io/gke-metadata-server-enabled:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="簡易功能驗證"><a href="#簡易功能驗證" class="headerlink" title="簡易功能驗證"></a>簡易功能驗證</h3><p>佈署以下服務，假設檔名為 wi-test.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">workload-identity-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">workload-identity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">google/cloud-sdk:slim</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">workload-identity-test</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>,<span class="string">&quot;infinity&quot;</span>]</span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">ksa-workload-identity</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">iam.gke.io/gke-metadata-server-enabled:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f wi-test.yaml</span><br></pre></td></tr></table></figure>

<p>進入 Pod 內</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it workload-identity-test \</span><br><span class="line">  --namespace workload-identity \</span><br><span class="line">  -- /bin/bash</span><br></pre></td></tr></table></figure>

<p>利用 curl 指令進行驗證：</p>
<ol>
<li><p>回傳內容為 GSA E-mail</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Metadata-Flavor: Google&quot;</span> http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email</span><br></pre></td></tr></table></figure></li>
<li><p>取得 Token </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Metadata-Flavor: Google&quot;</span> http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token</span><br></pre></td></tr></table></figure></li>
</ol>
<p>清理 Pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete -f wi-test.yaml</span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>如果是使用 Autopilot clusters 在設定上會有些許不同，此時建議直接參考官方文件會比較恰當</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity">https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity</a></li>
<li><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity">https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity</a></li>
</ul>
]]></content>
      <categories>
        <category>GCP</category>
      </categories>
      <tags>
        <tag>GKE</tag>
        <tag>Workload Identity</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 hexo-abbrlink 優化文章連結</title>
    <url>/posts/94411fbc/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 產生文章連結時，預設是使用「年/月/日/文章Title」的格式，導致 URL 太多層，如果是中文標題，複製下來的連結會過於冗長，這不僅不利於 SEO，也容易在二次編輯文章時，導致原先的連結失效。</p>
<p>最好的方式就是將文章的 URL 固定下來，這樣就可以一勞永逸，今天會使用 hexo-abbrlink 的套件來幫助我們達到固定 URL，而且不重複。</p>
<span id="more"></span>

<h2 id="hexo-abbrlink-的使用"><a href="#hexo-abbrlink-的使用" class="headerlink" title="hexo-abbrlink 的使用"></a>hexo-abbrlink 的使用</h2><p>這邊先提供 hexo-abbrlink 的 github 專案連結：</p>
<ul>
<li><a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></li>
</ul>
<p>以下的設定是依據我自身的設定提供參考</p>
<h3 id="安裝與確認"><a href="#安裝與確認" class="headerlink" title="安裝與確認"></a>安裝與確認</h3><p>安裝指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>確認是否有正確安裝</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm list | grep <span class="string">&quot;hexo-abbrlink&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以直接到 node_module 目錄底下去看有沒有 hexo-abbrlink 套件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./node_modules</span><br><span class="line">ls | grep <span class="string">&quot;hexo-abbrlink&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="設定檔調整"><a href="#設定檔調整" class="headerlink" title="設定檔調整"></a>設定檔調整</h3><p>編輯設定檔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ./_config.yml</span><br></pre></td></tr></table></figure>

<p>新增以下片段，這邊只提供自身的設定，如果有需要更 detail 的設定可以參照 <a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> GitHub 專案</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment">#support dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">true</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default)</span></span><br></pre></td></tr></table></figure>

<p>註解預設的 permalink，並且在下面增加新的設定，之後就會依照該格式產生連結</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br></pre></td></tr></table></figure>

<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>上述步驟都設定好之後，重新執行下述指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>套件就會依據 Title 自動產生一組亂數的 abbrlink 在文章的 markdown 原檔案上方，如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo-abbrlink 測試</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">categories:</span><br><span class="line">  - Hexo</span><br><span class="line">abbrlink: 11e41c6</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>abbrlink 一旦產生後，不論 Title 怎麼修改，abbrlink 都不會變動，除非將 abbrlink 刪除，重新 <code>hexo generate</code></p>
<p>確定 abbrlink 正常產出後，就可以 <code>hexo server</code> 進行本機測試，此時可以發現 URL 已經依照上面的設定改變了，會變成下面這種格式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://www.example.com/posts/11e41c6</span><br></pre></td></tr></table></figure>

<p>最後確認無誤就可以佈署發布囉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo加入Disqus留言功能</title>
    <url>/posts/eed23cc9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們利用 Hexo 架設好部落格並選定主題後，我們可能會希望讀者們可以針對文章予以回饋，這時候留言板功能就顯得格外重要，在 Hexo 中我們可以整併 Disqus 留言功能進去，讓文章的結尾可以有一塊專門留言的留言板，好讓讀者能夠留下寶貴的意見或問題</p>
<span id="more"></span>

<h2 id="Disqus-留言功能的使用"><a href="#Disqus-留言功能的使用" class="headerlink" title="Disqus 留言功能的使用"></a>Disqus 留言功能的使用</h2><p>Disqus 留言功能屬於第三方的功能，所以我們需要到 <a href="https://disqus.com/">Disqus 官方</a> 註冊帳號，註冊期間會請你填入 shortname，請留意一下，shortname 設定後是無法再修改的</p>
<p>註冊後再到 <code>./themes/next/_config.yml</code> 內 Disqus 的區塊去做設定，將 enable 參數值改成 true，shortname 的值改成 Disqus 當時申請時所填入的 shortname</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="comment"># For more information: https://disqus.com</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">YOUR_SHORTNAME</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>因 Disqus 屬於第三方管理，所以相關後台設定需要到 Disqus 登入自己的帳號來調整，例如：留言通知、更改語言等等…</p>
<p>這邊順便提一下，Disqus 預設不允許讀者在沒有登入 Disqus 的情況下進行留言，如果想要讓讀者可以在沒有登入 Disqus 的情況下留言，可以到 Disqus 的後台下述路徑去調整</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Settings → Admin → Edit Settings → 選擇要修改的部落格 → Coummunity → Moderation → Guest Commenting打勾</span><br></pre></td></tr></table></figure>

<blockquote>
<p>路徑的部分可能隨時間官方會有所調整，若有更動，可能需要稍微找一下</p>
</blockquote>
<p>雖然如此，但是讀者最少還是得留下「名字」跟「E-mail」才能進行留言，如圖</p>
<p><img src="mk-20240119114707.png"></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的關於功能</title>
    <url>/posts/8be085a8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 的關於(about) 功能，主要是可以讓讀者點進特定頁面來去了解作者本人，也就是作者的自我介紹頁，以下會介紹如何啟用與使用</p>
<span id="more"></span>

<h2 id="關於的使用"><a href="#關於的使用" class="headerlink" title="關於的使用"></a>關於的使用</h2><p>啟用關於功能，讓關於連結出現在網站上，首先調整 <code>./themes/next/_config.yml</code> 中的下述設定，將 <code>about: /about/ || fa fa-user</code> 註解「取消」，這樣就可以讓網站出現關於的連結</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>只有連結並沒有用處，點擊關於連結時，要能夠顯示相關頁面，所以使用下述指令，讓 Hexo 幫你產生連結檔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>Hexo 會在 <code>./source</code> 底下產生 about 目錄，目錄內會有一個 index.md 檔案</p>
<p>about 頁面建立後，還需將 index.md 檔案打開，並且加入 type 參數，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2021-04-20 15:37:19</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>這樣基本上關於功能就已經完成設定</p>
<p>使用時，只要在 <code>./source/about/index.md</code> 頁面以 Markdown 語法寫下自我介紹即可</p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>該篇與 Hexo的分類/標籤功能 設定方式極度雷同，如有需要可以搭配一起設定，另外兩篇請參考下面連結</p>
<ul>
<li><a href="https://blog.tonyjhang.dev/posts/8bfb5405">Hexo的分類功能</a></li>
<li><a href="https://blog.tonyjhang.dev/posts/1436c3e2">Hexo的標籤功能</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GitHub Pages</title>
    <url>/posts/9836e9cf/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們開發程式時，一定都會想到 GitHub 或 GiLab 等版控的工具，今天要來介紹一下 GitHub Pages，GitHub Pages 是由 GitHub 所提供的服務，可以讓 Repository 內的靜態檔案，以網頁的方式呈現出來，這代表著 GitHub Pages 提供了 Web Server 的服務，但僅僅支援靜態頁面，如果是後端相關的 code，例如: .php 的副檔名，GitHub Pages 是不會有作用的，所以很多人會使用 GitHub Pages 來架設自己的部落格(Blog)。</p>
<span id="more"></span>

<h2 id="如何使用-GitHub-Pages"><a href="#如何使用-GitHub-Pages" class="headerlink" title="如何使用 GitHub Pages"></a>如何使用 GitHub Pages</h2><p>這邊假設大家對於 Git 的使用都已經熟悉了，在依據下面幾個步驟就可以完成 GitHub Pages</p>
<ul>
<li>新增專案(Repository)</li>
<li>建立測試檔</li>
<li>測試網頁功能</li>
</ul>
<h3 id="新增專案-Repository"><a href="#新增專案-Repository" class="headerlink" title="新增專案(Repository)"></a>新增專案(Repository)</h3><p>在專案名稱的地方，填寫「<code>username</code>.github.io」，這個 <code>username</code> 指的是自己的 GitHub 帳號。 並設定為 Public，不建立 README.md 的檔案，後續要新增測試檔案時再自己針對目錄做 Git Initial。</p>
<blockquote>
<p>要使用 GitHub Pages，Repository 需要設定為 Public</p>
</blockquote>
<p><img src="mk-20240119120313.png"></p>
<h3 id="建立測試檔"><a href="#建立測試檔" class="headerlink" title="建立測試檔"></a>建立測試檔</h3><p>接下來，在本機建立一個目錄並進入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir username.github.io</span><br><span class="line"><span class="built_in">cd</span> username.github.io</span><br></pre></td></tr></table></figure>

<p>並寫一個測試的首頁 index.html</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span> &gt; index.html</span><br></pre></td></tr></table></figure>

<p>初始化目錄並設定 Rmote Repository</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述 username 請填入自己的 GitHub 帳號</p>
</blockquote>
<p>提交檔案並推上 GitHub</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="測試網頁功能"><a href="#測試網頁功能" class="headerlink" title="測試網頁功能"></a>測試網頁功能</h3><p>成功推送後，可以開啟 https://<code>username</code>.github.io 試試看，會顯示「Hello World」</p>
<blockquote>
<p>測試的時候，可以的話盡量開啟無痕視窗來測試，這樣比較不會因為多次修改而造成 cache 的問題</p>
</blockquote>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://pages.github.com/">https://pages.github.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo建立草稿</title>
    <url>/posts/946e0e0b/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 Hexo 來當作技術部落格不僅簡單且快速，在剛開始架設完成後，可以使用指令 <code>hexo new [title]</code> 來建立文章並且撰寫，但是這樣的方式會延伸一個問題，如果這篇文章還處理撰寫的階段，但是我有修改其他已完成的文章需要發佈出去，但是不想把未完成的文章也一起發佈，此時就會有一些困擾，此篇會來說明如果使用 Hexo 的草稿功能。</p>
<span id="more"></span>

<h2 id="Hexo-草稿"><a href="#Hexo-草稿" class="headerlink" title="Hexo 草稿"></a>Hexo 草稿</h2><p>一般來說，我們建立文章都是使用此指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [Title] [FileName]</span><br></pre></td></tr></table></figure>

<p>如果今天要建立 Hexo 草稿，我們可以將上述指令改成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new draft [Title] [FileName]</span><br></pre></td></tr></table></figure>

<p>那此時產生出來的草稿會放在 <code>./source/_drafts</code></p>
<blockquote>
<p>如果是使用 <code>hexo new [title]</code> 則會放在 <code>./source/_posts</code></p>
</blockquote>
<p>當我們要發佈一篇文章時，我們會使用 <code>hexo g</code> 和 <code>hexo d</code> 來編譯產生靜態檔與發佈文章，而草稿目錄內的文章不會被發佈出去，是 <strong>因為 <code>hexo g</code> 並不會編譯 <code>./source/_drafts</code> 底下的檔案</strong>。</p>
<p>如果放在草稿目錄底下的文章完成後，想在本機先預覽檢查時，可以使用此指令</p>
<blockquote>
<p>此處「文後討論」有補充說明</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s --draft</span><br></pre></td></tr></table></figure>

<p>確認文章沒問題後，我們就可以將草稿 publish，使用此指令</p>
<blockquote>
<p>這邊的 publish 是將檔案從 _drafts 移動到 _posts</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo publish [FileName]  <span class="comment"># 這邊是接 FileName，不包含副檔名 .md</span></span><br></pre></td></tr></table></figure>

<p>接下來就跟放在 _posts 底下的文章發佈沒有兩樣，先進行移除舊的靜態檔與快取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br></pre></td></tr></table></figure>

<p>然後進行編譯的動作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>最後再發佈</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>看完上述，你可能會想，那能不能讓 <code>hexo s</code> 自動將 _drafts 底下的檔案自動預覽出來，而不要在指令後面又多加一個參數 <code>--draft</code>?</p>
<p>答案是 可以的!</p>
<p>只要去調整 <code>./_config.yml</code> 內的設定，將下面的參數值由 false 調整為 true 即可</p>
<blockquote>
<p>非 themes 底下的 _config.yml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">render_drafts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>調整之後，以後要預覽 _drafts 內的文章，就跟一般放在 _posts 底下的一樣，只要使用 <code>hexo s</code> 通通都可以在本機預覽得到。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://www.dazhuanlan.com/2019/11/02/5dbc7ecc737a5/">https://www.dazhuanlan.com/2019/11/02/5dbc7ecc737a5/</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的標籤功能</title>
    <url>/posts/1436c3e2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 網站中的文章可以使用標籤(tags)，標籤有點像是關鍵字的作用，可以替每篇不同的文章給予不同的標籤，這可以讓讀者針對標籤來快速篩選文章</p>
<span id="more"></span>

<h2 id="標籤的使用"><a href="#標籤的使用" class="headerlink" title="標籤的使用"></a>標籤的使用</h2><p>啟用標籤功能，讓標籤連結出現在網站上，首先調整 <code>./themes/next/_config.yml</code> 中的下述設定，將 <code>tags: /tags/ || fa fa-tags</code> 註解「取消」，這樣就可以讓網站出現標籤的連結</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>只有連結並沒有用處，點擊標籤連結時，要能夠顯示相關頁面，所以使用下述指令，讓 Hexo 幫你產生連結檔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>Hexo 會在 <code>./source</code> 底下產生 tags 目錄，目錄內會有一個 index.md 檔案</p>
<p>tags 頁面建立後，還需將 index.md 檔案打開，並且加入 type 參數，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2021-04-20 15:37:19</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>這樣基本上標籤功能就已經完成設定</p>
<p>在使用時，只要在文章建立後加上 tags，並把要標籤的值加上去即可，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 標籤測試</span><br><span class="line">tags:</span><br><span class="line">  - TEST</span><br><span class="line">  - TAG</span><br><span class="line">date: 2021-05-22 16:17:39</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>該篇與 Hexo的分類/關於功能 設定方式極度雷同，如有需要可以搭配一起設定，另外兩篇請參考下面連結</p>
<ul>
<li><a href="https://blog.tonyjhang.dev/posts/8bfb5405">Hexo的分類功能</a></li>
<li><a href="https://blog.tonyjhang.dev/posts/8be085a8">Hexo的關於功能</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何修改 PHP-FPM 上傳檔案大小限制</title>
    <url>/posts/452fc7c7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>網頁上傳檔案屬於後端運作，如果檔案太大可能會造成上傳失敗，如果是採 Nginx + PHP-FPM 的架構，此時需要修改後端(PHP-FPM) <code>php.ini</code> 的相關參數設定。</p>
<p>可以分為兩個面向：</p>
<ul>
<li>檔案上傳大小限制</li>
<li>腳本執行時間或網路連線時間的長短限制</li>
</ul>
<span id="more"></span>

<p>相關參數如下：</p>
<blockquote>
<p>此處的數值為預設值</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 檔案上傳大小限制相關參數</span><br><span class="line">upload_max_filesize = 2M</span><br><span class="line">post_max_size = 8M</span><br><span class="line">memory_limit = 128M</span><br><span class="line"></span><br><span class="line"># 腳本執行時間或網路連線時間的限制</span><br><span class="line">max_execution_time = 60</span><br><span class="line">max_input_time = 60</span><br><span class="line">default_socket_timeout = 60</span><br></pre></td></tr></table></figure>

<h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><p>依照自身需求，調整 <code>php.ini</code> 的相關參數設定</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 上傳單一檔案大小</span><br><span class="line">upload_max_filesize = 100M</span><br><span class="line"></span><br><span class="line"># 使用表單 POST 給 PHP 的大小上限(所有檔案大小加總)</span><br><span class="line">post_max_size = 8M</span><br><span class="line"></span><br><span class="line"># 單一 PHP 腳本使用記憶體的上限</span><br><span class="line">memory_limit = 128M</span><br></pre></td></tr></table></figure>

<p>這邊需要注意的是，上述參數之間的值有大小原則需要注意</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">memory_limit &gt; post_max_size &gt; upload_max_filesize</span><br></pre></td></tr></table></figure>

<p>到此就可以讓上傳檔案的大小再往上提升，不過接下來你可能會遇到檔案傳送到一半會斷線的情況，這代表傳送的檔案較大需要較多的時間，此時就需要再調整有關腳本執行的時間與網路連線的相關設定。</p>
<hr>
<p>有關 PHP 腳本執行的時間與網路連線時間長短的相關參數：</p>
<blockquote>
<p>此處的數值為預設值</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># PHP 腳本執行的時間上限(秒)，可避免無窮迴圈</span><br><span class="line">max_execution_time = 30</span><br><span class="line"></span><br><span class="line"># 每個 PHP 腳本接收資料的時間上限(秒)，如果網路較慢，時間可能需要拉長</span><br><span class="line">max_input_time = 60</span><br><span class="line"></span><br><span class="line"># Socket 無回應斷線時間上限</span><br><span class="line">default_socket_timeout = 60</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>max_input_time</code> 數值若為 -1 表示無限制時間</p>
</blockquote>
<p>此處可以依照自身的 PHP 腳本與網路環境來調整到符合自身的需求</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://blog.gtwang.org/web-development/php-ini-large-file-upload-configuration/">https://blog.gtwang.org/web-development/php-ini-large-file-upload-configuration/</a></li>
</ul>
]]></content>
      <categories>
        <category>PHP-FPM</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo的分類功能</title>
    <url>/posts/8bfb5405/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 的分類功能其實跟資料夾的功能差不多，作者可以自行將文章做分類，讓讀者在找尋時可以依據分類來快速找到相關的文章，功能上與標籤(tags) 有點大同小異</p>
<span id="more"></span>

<h2 id="分類的使用"><a href="#分類的使用" class="headerlink" title="分類的使用"></a>分類的使用</h2><p>啟用分類功能，讓分類連結出現在網站上，首先調整 <code>./themes/next/_config.yml</code> 中的下述設定，將 <code>categories: /categories/ || fa fa-th</code> 註解「取消」，這樣就可以讓網站出現分類的連結</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>只有連結並沒有用處，點擊分類連結時，要能夠顯示相關頁面，所以使用下述指令，讓 Hexo 幫你產生連結檔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>Hexo 會在 <code>./source</code> 底下產生 categories 目錄，目錄內會有一個 index.md 檔案</p>
<p>categories 頁面建立後，還需將 index.md 檔案打開，並且加入 type 參數，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2021-04-20 15:37:19</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>這樣基本上分類功能就已經完成設定</p>
<p>在使用時，只要在文章建立後加上 categories，並把要分類的值加上去即可，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分類測試</span><br><span class="line">date: 2021-05-22 16:17:39</span><br><span class="line">categories:</span><br><span class="line">  - Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>這樣該篇文章就會被納入 Hexo 這個分類底下</p>
<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>如果文章內的 categories 設定如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分類測試</span><br><span class="line">date: 2021-05-22 16:17:39</span><br><span class="line">categories:</span><br><span class="line">  - Hexo</span><br><span class="line">  - NexT</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>此時該文章將被分類到 Hexo 中的 NexT 底下，如：Hexo/NexT/分類測試</p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>該篇與 Hexo的標籤/關於功能 設定方式極度雷同，如有需要可以搭配一起設定，另外兩篇請參考下面連結</p>
<ul>
<li><a href="https://blog.tonyjhang.dev/posts/1436c3e2">Hexo的標籤功能</a></li>
<li><a href="https://blog.tonyjhang.dev/posts/8be085a8">Hexo的關於功能</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Network Policy</title>
    <url>/posts/e08900fb/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 K8s 中，預設所有 Pod 不管是在哪個 Namespace，預設都是相通，若是想要進一步限制 Pod 之間的存取，可以使用 Network Policy 來達成。</p>
<p>在 Google Kubernetes Engine 的環境中，可以自行啟用「Calico Kubernetes Network 政策」，即可輕鬆簡單的直接使用。</p>
<span id="more"></span>

<h2 id="Network-Policy-描述檔"><a href="#Network-Policy-描述檔" class="headerlink" title="Network Policy 描述檔"></a>Network Policy 描述檔</h2><p>基本範例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-vts</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">repo:</span> <span class="string">sugar</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">department:</span> <span class="string">rd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9453</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9527</span></span><br></pre></td></tr></table></figure>

<h3 id="分段解析"><a href="#分段解析" class="headerlink" title="分段解析"></a>分段解析</h3><h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-vts</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>在 <code>default</code> Namespace 中只要帶有 Label 為 <code>app=nginx-vts</code> 的 pod，接會被套上 Network Policy，並且進(ingress) 出(egress)流量皆會被限制。</p>
<blockquote>
<p>如果沒有設定 <code>spec.podSelector</code>，代表會套用到 <code>default</code> Namespace 中的所有 pod</p>
</blockquote>
<p>至於進(ingress) 出(egress)流量的限制細節，需要再往後設定</p>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>Ingress 流量的詳細設定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-vts</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">repo:</span> <span class="string">sugar</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">department:</span> <span class="string">rd</span></span><br><span class="line">    <span class="comment"># IP 範圍，而非 IP 封鎖</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9453</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>Ingress from：管理從外部進來的流量，也就「允許」進來 Pod 的流量</p>
<p>允許存取的來源白名單：</p>
<ul>
<li>允許 <code>default</code> Namespace 中帶有 <code>repo=sugar</code> Label 的 Pod</li>
<li>允許帶有 <code>department=rd</code> Label 的 Namespace 中所有 Pod</li>
<li>來源 IP 範圍 172.17.0.0/16 (不含 172.17.1.0/24)</li>
</ul>
<p>綜合 Part 1 的解析，會變成如下：</p>
<ul>
<li>允許 <code>default</code> Namespace 中帶有 <code>repo=sugar</code> Label 的 Pod，存取 <code>default</code> Namespace 中帶有 <code>app=nginx-vts</code> 標籤 Pod 的 9453 Port</li>
<li>允許帶有 <code>department=rd</code> Label 的 Namespace 中所有 Pod，存取 <code>default</code> Namespace 中帶有 <code>app=nginx-vts</code> 標籤 Pod 的 9453 Port</li>
<li>允許來源 IP 為 172.17.0.0/16(但排除 172.17.1.0/24)，存取 <code>default</code> Namespace 中帶有 <code>app=nginx-vts</code> 標籤 Pod 的 9453 Port</li>
</ul>
<h4 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h4><p>Egress 流量的詳細設定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-vts</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="comment"># IP 範圍，而非 IP 封鎖</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9527</span></span><br></pre></td></tr></table></figure>

<p>Egress to：管理從內部出去的流量，也就是「允許」從 Pod 的出去到達的目的流量</p>
<p>「允許」從 Pod 的出去到達的目的流量白名單：</p>
<ul>
<li>只允許對外連線(egress) 到 IP 範圍 10.0.0.0/24 的 通訊協定 TCP 且目的 Port 為 9527。</li>
</ul>
<p>綜合 Part 1 的解析，會變成如下：</p>
<p>「在 <code>default</code> 的命名空間中只要帶有 Label 為 <code>app=nginx-vts</code> 的 pod，只允許對外連線(egress) 到 IP 範圍 10.0.0.0/24 的 通訊協定 TCP 且目的 Port 為 9527」</p>
<h4 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h4><p>從上述的解析中可以推論，不管是 Ingress 或是 Egress，對於設定上皆有三種白名單的細部控制：<code>podSelector</code>、<code>namespaceSelector</code>、<code>ipBlock</code></p>
<h2 id="預設政策-default-policy"><a href="#預設政策-default-policy" class="headerlink" title="預設政策(default policy)"></a>預設政策(default policy)</h2><p>基本概念(重要)：</p>
<ul>
<li>若要選擇所有的 pod，則將 <code>podSelector</code> 設定為 <code>&#123;&#125;</code></li>
<li>若是設定 <code>policyType</code>，就表示要全部拒絕該種連線(ingress/egress) 的流量</li>
<li>若要打開上面的限制(也就是白名單)，則要在 <code>spec.ingress</code> 或 <code>spec.egress</code> 中設定</li>
</ul>
<p>綜合上述，可以推理出四種情況：</p>
<ul>
<li>拒絕從外面進來的流量，要在 <code>spec.policyTypes</code> 中包含 Ingress，並且略過 ingress 細部設定</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deny-all-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br></pre></td></tr></table></figure>

<ul>
<li>拒絕從內部出去的流量，要在 <code>spec.policyTypes</code> 中包含 Egress，並且略過 egress 細部設定</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deny-all-egress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接受從外面進來的網路流量，要在 <code>spec.policyTypes</code> 中包含 Ingress，並將 <code>spec.ingress</code> 設定為 <code>&#123;&#125;</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">allow-all-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接受從內部出去的網路流向，要在 <code>spec.policyTypes</code> 中包含 Egress，並將 <code>spec.egress</code> 設定為 <code>&#123;&#125;</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">allow-all-egress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在理解完上述情況後後，記得帶上 Namespace 的概念進去，這樣才知道該條政策的作用範圍：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">allow-all-egress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>在 <code>default</code> Namespace 中所有的 pod(<code>podSelector: &#123;&#125;</code>)，皆會被套上 Network Policy，並且進(ingress) 出(egress)流量皆會被限制。</p>
<h2 id="更多的使用場景"><a href="#更多的使用場景" class="headerlink" title="更多的使用場景"></a>更多的使用場景</h2><p>下述參考資料中，有更多的使用場景可以參照：</p>
<p><a href="https://kubernetes.feisky.xyz/concepts/objects/network-policy#shi-yong-chang-jing">https://kubernetes.feisky.xyz/concepts/objects/network-policy#shi-yong-chang-jing</a></p>
<h3 id="只允許同一個-Namespace-間的-Pod-相互訪問"><a href="#只允許同一個-Namespace-間的-Pod-相互訪問" class="headerlink" title="只允許同一個 Namespace 間的 Pod 相互訪問"></a>只允許同一個 Namespace 間的 Pod 相互訪問</h3><p>只允許 <code>monitoring</code> Namespace 間的 Pod 可以相互訪問，其他 Namespace 的 Pod 無法訪問 <code>monitoring</code> Namespace 的 Pod</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deny-other-namespaces</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="禁止同一個-Namespace-間的-Pod-相互訪問，但是跨-Namespace-不在此限"><a href="#禁止同一個-Namespace-間的-Pod-相互訪問，但是跨-Namespace-不在此限" class="headerlink" title="禁止同一個 Namespace 間的 Pod 相互訪問，但是跨 Namespace 不在此限"></a>禁止同一個 Namespace 間的 Pod 相互訪問，但是跨 Namespace 不在此限</h3><p>禁止 <code>default</code> Namespace 間的 Pod 相互訪問，但 <code>default</code> Namespace 可以訪問其他 Namespace 的 Pod，其他 Namespace 的 Pod 也可以訪問 <code>default</code> Namespace 的 Pod </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-deny</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://godleon.github.io/blog/Kubernetes/k8s-Network-Policy-Overview/">https://godleon.github.io/blog/Kubernetes/k8s-Network-Policy-Overview/</a></li>
<li><a href="https://kubernetes.feisky.xyz/concepts/objects/network-policy#shi-yong-chang-jing">https://kubernetes.feisky.xyz/concepts/objects/network-policy#shi-yong-chang-jing</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Network Policy</tag>
      </tags>
  </entry>
  <entry>
    <title>htpasswd的使用</title>
    <url>/posts/c66ce192/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在測試 Traefik BasicAuth 功能時，需要使用 MD5/SHA1/Bcrypt 三種其中一種方式來加密密碼，並寫到設定檔裡</p>
<p>常見的 Nginx/Apache 也有內建網頁的基本身份驗證，這時候也會需要使用 htpasswd 來將使用者的密碼加密並寫進設定檔</p>
<p>下面會介紹如何使用 htpasswd 指令來產生加密密碼</p>
<span id="more"></span>

<h2 id="htpasswd的使用"><a href="#htpasswd的使用" class="headerlink" title="htpasswd的使用"></a>htpasswd的使用</h2><p>其實使用的方式很簡單，只要將使用者的「帳號」與「密碼」丟給 htpasswd，他就會自動幫你加密指定密碼並且整理好格式輸出給你使用，詳細可以參考下面的實際範例</p>
<p>使用 Bcrypt 加密密碼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Format</span><br><span class="line">htpasswd -nb -B [username] [password]</span><br><span class="line"></span><br><span class="line"># Example</span><br><span class="line">htpasswd -nb -B tony 1234</span><br><span class="line"></span><br><span class="line"># Output</span><br><span class="line">tony:$2y$05$c1xVKSuI8mbPRNll.t.P0OjXC2RShcGww2PBslit0mk.wnatG1cIy</span><br></pre></td></tr></table></figure>

<p>使用 MD5 加密密碼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Format</span><br><span class="line">htpasswd -nb -m [username] [password]</span><br><span class="line"></span><br><span class="line"># Example</span><br><span class="line">htpasswd -nb -m tony 1234</span><br><span class="line"></span><br><span class="line"># Output</span><br><span class="line">tony:$apr1$eRtkDKOy$shi95jDEBupv6F5XcpXyL&#x2F;</span><br></pre></td></tr></table></figure>

<p>使用 SHA1 加密密碼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Format</span><br><span class="line">htpasswd -nb -s [username] [password]</span><br><span class="line"></span><br><span class="line"># Example</span><br><span class="line">htpasswd -nb -s tony 1234</span><br><span class="line"></span><br><span class="line"># Output</span><br><span class="line">tony:&#123;SHA&#125;cRDtpNCeBiql5KOQsKVyrA0sAiA&#x3D;</span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>最詳細的使用說明，可以使用 <code>--help</code> 來檢視</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ htpasswd --help</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">	htpasswd [-cimBdpsDv] [-C cost] passwordfile username</span><br><span class="line">	htpasswd -b[cmBdpsDv] [-C cost] passwordfile username password</span><br><span class="line"></span><br><span class="line">	htpasswd -n[imBdps] [-C cost] username</span><br><span class="line">	htpasswd -nb[mBdps] [-C cost] username password</span><br><span class="line"> -c  Create a new file.</span><br><span class="line"> -n  Don&#39;t update file; display results on stdout.</span><br><span class="line"> -b  Use the password from the command line rather than prompting for it.</span><br><span class="line"> -i  Read password from stdin without verification (for script usage).</span><br><span class="line"> -m  Force MD5 encryption of the password (default).</span><br><span class="line"> -B  Force bcrypt encryption of the password (very secure).</span><br><span class="line"> -C  Set the computing time used for the bcrypt algorithm</span><br><span class="line">     (higher is more secure but slower, default: 5, valid: 4 to 31).</span><br><span class="line"> -d  Force CRYPT encryption of the password (8 chars max, insecure).</span><br><span class="line"> -s  Force SHA encryption of the password (insecure).</span><br><span class="line"> -p  Do not encrypt the password (plaintext, insecure).</span><br><span class="line"> -D  Delete the specified user.</span><br><span class="line"> -v  Verify password for the specified user.</span><br><span class="line">On other systems than Windows and NetWare the &#39;-p&#39; flag will probably not work.</span><br><span class="line">The SHA algorithm does not use a salt and is less secure than the MD5 algorithm.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo文章插入圖片</title>
    <url>/posts/21f441c6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 中的文章是使用 Markdown 的語法，有時候文章中可能會需要一些圖片來予以輔助，這時候我們可能會需要調整一些設定來存放我們的圖片</p>
<h2 id="文章插入圖片"><a href="#文章插入圖片" class="headerlink" title="文章插入圖片"></a>文章插入圖片</h2><p>這邊先講一下 Markdown 插入圖片的語法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](圖片路徑)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>再來我們可以更改 Hexo 的設定檔，來讓我們建立文章時，能夠自動將該文章存放圖片的目錄也一起建立起來，修改 <code>./_config.xml</code>，並將下面參數值調整為 true</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>調整後當我們使用 <code>hexo new &quot;新文章&quot;</code> 建立文章後，就會自動在 <code>./source/_posts</code> 建立一個與文章相同名稱的目錄，然後就能將圖片放進去</p>
<p>而 Markdown 要調用圖片時，圖片路徑只需要填上圖片名稱即可，例如：圖片名稱為 123.png</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](123.png)</span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>上述方式對於每篇文章都需要插入圖片的使用者非常方便，但是如果你的文章只有少數幾篇需要圖片輔助的話，可能會造成 <code>./source/_posts</code> 會有很多空的目錄，所以如果只有少數幾篇需要使用到圖片的話，這邊給兩個建議：</p>
<ol>
<li>設定自動建立圖片存放目錄，然後自己手動將無需使用到圖片的文章的目錄刪除</li>
<li>乾脆不要設定，自己手動建立與文章相同名稱的目錄來存放圖片</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 連線出現「WARNING:REMOTE HOST IDENTIFICATION HAS CHANGED!」</title>
    <url>/posts/67cc021f/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Linux 環境中，我們常常使用 SSH 來與目標主機做連線，有時候因為目標主機的異動而導致我們後續連線時會出現 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED這樣子的警示訊息，導致我們無法順利連線，為何會有這樣子的訊息，又該如何解決，可以參考以下內容</p>
<span id="more"></span>

<h2 id="連線原理"><a href="#連線原理" class="headerlink" title="連線原理"></a>連線原理</h2><p>SSH 連接遠端主機時，會檢查主機的 Public key，如果是第一次連線該主機，會顯示該主機的 public key fingerprint，詢問使用者信任該主機並繼續連線</p>
<blockquote>
<p>A public key fingerprint is a short sequence of bytes used to identify a longer public key.</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;192.168.26.11 (192.168.26.11)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is a3:ca:ad:95:a1:45:d2:57:3a:e9:e7:75:a8:4c:1f:9f.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>當選擇 yes，就會將該主機的 Public key 追加到本機 <code>~/.ssh/known_hosts</code> 中，當第二次連到該台主機時，就不會再出現相關訊息</p>
<h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><p>這樣子的 Public key 檢查是一個重要的安全機制，可以防範中間人攻擊等問題，但有時候因爲某些原因，導致該 IP 的 Public key 改變了，這時候使用 SSH 連線時，會出現以下錯誤訊息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">e9:0c:36:89:7f:3c:07:71:09:5a:9f:28:8c:44:e9:05.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/tonyjhang/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending key in /home/tonyjhang/.ssh/known_hosts:81</span><br><span class="line">RSA host key for 192.168.26.11 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>有三種解決方式</p>
<ol>
<li>根據上述訊息，將第 81 行刪除，重新連線，主機會重新傳送一份 public key fingerprint</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Offending key in /home/tonyjhang/.ssh/known_hosts:81</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把整個 <code>~/.ssh/known_hosts</code> 刪除，這是最「不建議」的做法，可能會導致自動化失效或連線到其他主機的問題</li>
<li>使用 <code>ssh-keygen -R</code> 的指令，將 <code>~/.ssh/known_hosts</code> 內的所有資訊，轉存一份到 <code>~/.ssh/known_hosts.old</code>，並且將 <code>~/.ssh/known_hosts</code> 內的目標主機項目移除，使用方式如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -R 192.168.26.11</span><br><span class="line"></span><br><span class="line"><span class="comment"># Host 192.168.26.11 found: line 60</span></span><br><span class="line">/Users/tony_jhang/.ssh/known_hosts updated.</span><br><span class="line">Original contents retained as /Users/tony_jhang/.ssh/known_hosts.old</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Original contents retained as /Users/tony_jhang/.ssh/known_hosts.old → 原始內容有被保存到 known_hosts.old</p>
</blockquote>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Public_key_fingerprint">https://en.wikipedia.org/wiki/Public_key_fingerprint</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>TIME_WAIT狀態如何產生</title>
    <url>/posts/ab6fcbda/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前 Maintain A團隊的 K8s 時，有發生過 golang 寫的服務太多的 TIME_WAIT 導致 Pod 無法建立新的連線。 近期 Maintain B團隊的服務時，因為線上人數變多，擔心 Nginx 向 Upstream 發請求時，會不會造成太多的連線，然後有過多的 TIME_WAIT 現象，因為預設 Nginx 向 Upstream 發送請求是使用 http/1.0，會導致連線無法複用，所以當連線一多時，就很容易發生過多的 TIME_WAIT 狀態。</p>
<p>所以本篇主要是在講解 TCP 協定在「建立連線」與「關閉連線」的過程，只要了解運作過程，就會知道 TIME_WAIT 狀態到底是如何產生的</p>
<span id="more"></span>

<h2 id="TCP-建立連線"><a href="#TCP-建立連線" class="headerlink" title="TCP 建立連線"></a>TCP 建立連線</h2><p>依據 IETF 的標準文件 <a href="http://www.rfc-editor.org/rfc/rfc793.txt">rfc793</a> 中所描述的情形，可分為以下四種不同狀況</p>
<ul>
<li>Basic 3-Way Handshake for Connection Synchronization</li>
<li>Simultaneous Connection Synchronization</li>
<li>Recovery from Old Duplicate SYN</li>
<li>Half-Open Connection Discovery</li>
</ul>
<p>以下僅針對第一個 Basic 3-Way Handshake for Connection Synchronization 進行說明</p>
<p>通常 TCP 連線建立流程，需要經過三向交握(three-way handshaking) 來建立連線</p>
<p><img src="mk-20240119120657.png"></p>
<ol>
<li>Server 建立 TCB，開啟監聽連線，進入 LISTENING 狀態</li>
<li>Client 主動發出連線請求 SYN，進入 SYN_SENT 狀態，並等待回應</li>
<li>Server 收到 SYN 要求，回應連線 SYN,ACK，並進入 SYN_RCVD 狀態</li>
<li>Client 收到 SYN,ACK 確認完成連線進入 ESTABLISHED 狀態，並送出 ACK</li>
<li>Server 收到 ACK 確認連線完成，同時也進入 ESTABLISHED 狀態</li>
</ol>
<p>名詞解釋：</p>
<ul>
<li>CLOSED：已關閉連線，表示該主機的連線呈現關閉中</li>
<li>LISTENING：監聽狀態，表示該主機被動等待連線請求</li>
<li>SYN_SENT：表示已送出 SYN 訊息，並等待對方回應</li>
<li>SYN_RCVD：表示已接收到對方的 SYN 訊息，並且送出 SYN,ACK，等待對方回應</li>
<li>ESTABLISHED：表示已完成雙方連線的建立，可開始傳輸資料</li>
<li>TCB：傳輸控制區塊(Transmission Control Block)，用來儲存 Server 端有關 TCP 的所有資訊</li>
<li>SYN：Synchronous，表示與對方建立連線的請求</li>
<li>ACK：Acknowledgement，表示發送的數據已收到無誤</li>
</ul>
<p>「TCP建立連線」狀態流程圖</p>
<p><img src="mk-20240119120730.png"></p>
<h2 id="TCP-關閉連線"><a href="#TCP-關閉連線" class="headerlink" title="TCP 關閉連線"></a>TCP 關閉連線</h2><p>依據 IETF 的標準文件 <a href="http://www.rfc-editor.org/rfc/rfc793.txt">rfc793</a> 中所描述的情形，可分為以下二種不同狀況</p>
<ul>
<li>Normal Close Sequence</li>
<li>Simultaneous Close Sequence</li>
</ul>
<p>以下僅針對第一個 Normal Close Sequence 進行說明</p>
<p>TCP 關閉流程如下，需要經過四次交握 (four-way handshaking)，來確認雙方都停止收發數據，<strong>要注意的是可以是由 server 發起主動關閉，或是 client 發起主動關閉</strong>，但是「通常」都是 client 發起，因此下圖使用 TCP A 與 TCP B 表示，：</p>
<p><img src="mk-20240119120822.png"></p>
<ol>
<li>TCP A：準備關閉連線，發出 FIN，進入 FIN_WAIT_1 狀態</li>
<li>TCP B：收到 FIN，並回傳 ACK，進入 CLOSE_WAIT 狀態，並通知 Application 連線準備關閉</li>
<li>TCP A：收到 ACK，進入 FIN_WAIT_2 狀態，並等待對方發出 FIN</li>
<li>TCP B：確認 Application 處理完斷線請求，發出 FIN，並進入狀態 LAST_ACK</li>
<li>TCP A：收到 FIN，並回傳 ACK，進入 TIME_WAIT 狀態，等待 2MSL 時間後正式關閉連線</li>
<li>TCP B：收到 ACK，便直接關閉連線，進入 CLOSED 狀態</li>
</ol>
<p>名詞解釋：</p>
<ul>
<li>ESTABLISHED：表示已完成雙方連線的建立，可開始傳輸資料</li>
<li>CLOSE_WAIT：等待連線關閉狀態，等待 Application 回應</li>
<li>LAST_ACK：等待連線關閉狀態，等待對方回傳 ACK 後關閉連線</li>
<li>FIN_WAIT_1：等待連線關閉狀態，等待對方回傳 ACK</li>
<li>FIN_WAIT_2：等待連線關閉狀態，等待對方回傳 FIN</li>
<li>TIME_WAIT：等待2MSL，保證遠端有收到其 ACK 關閉連線 (網路延遲問題)</li>
<li>CLOSED：已關閉連線</li>
<li>FIN：FINISH，表示關閉連線的請求</li>
<li>ACK：Acknowledgement，表示發送的數據已收到無誤</li>
</ul>
<p>「TCP關閉連線」狀態流程圖</p>
<p><img src="mk-20240119120856.png"></p>
<p>最後發送 ACK 時，會進入 TIME_WAIT 狀態，要等 2MSL 時間後，這條連接才真正消失，所以從這邊知道「主動關閉連線」的一方會進入 TIME_WAIT 狀態</p>
<blockquote>
<p>什麼是 MSL 時間<br>最大分段壽命 MSL(Maximum Segment Lifetime)，是 TCP 協定規定封包在網絡中最長生存時間，超出時間後封包就會被丟棄。</p>
<p>RFC793 定義 MSL 為 2 分鐘，不過實際上不同的作業系統可能有不同的設定，以 Linux 為例，通常是 30 秒，2MSL 就是 60 秒</p>
</blockquote>
<h2 id="為何-TIME-WAIT-狀態要等待-2MSL-的時間呢"><a href="#為何-TIME-WAIT-狀態要等待-2MSL-的時間呢" class="headerlink" title="為何 TIME_WAIT 狀態要等待 2MSL 的時間呢?"></a>為何 TIME_WAIT 狀態要等待 2MSL 的時間呢?</h2><p>Client/Server 都完成了四次交握，代表 Client/Server 都同意關閉連線，照理說應該可以直接回到 CLOSED 狀態(就像是建立連線時 SYN_SEND 狀態到 ESTABLISH 狀態那樣)，但是這邊我們必須要假設網路傳輸是不可靠的，因為我們無法保證最後傳送的 ACK 對方一定會收到，傳輸過程中可能因為種種原因(例如：網路延遲、丟包等…) 導致對方一直處於 LAST_ACK 狀態下的 SOCKET 因為逾時而未收到 ACK 而重發 FIN，所以 TIME_WAIT 狀態的作用就是用來重發可能遺失的 ACK。</p>
<p>TIME_WAIT 狀態，是為了避免因為網路傳輸的種種原因而造成的 TCP 傳輸不可靠，而 TIME_WAIT 狀態可以最大限度的提升網路傳輸的可靠性。</p>
<h2 id="完整-TCP「建立連線」與「關閉連線」之狀態圖"><a href="#完整-TCP「建立連線」與「關閉連線」之狀態圖" class="headerlink" title="完整 TCP「建立連線」與「關閉連線」之狀態圖"></a>完整 TCP「建立連線」與「關閉連線」之狀態圖</h2><p><img src="mk-20240119120922.png"></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://dev.twsiyuan.com/2017/09/tcp-states.html">https://dev.twsiyuan.com/2017/09/tcp-states.html</a></li>
<li><a href="https://www.gushiciku.cn/pl/p0aJ/zh-tw">https://www.gushiciku.cn/pl/p0aJ/zh-tw</a></li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title>Kubernetes 更新 ConfigMap 或 Secret 自動重啟 Pod</title>
    <url>/posts/1a2eedde/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有在使用 K8s 的朋友，後期應該都會遇到一個問題，內部服務有一些設定檔是使用 ConfigMap 單獨掛出來，或是一些機敏資料是使用 Secret 掛出來，當這些單獨掛出來的資料有異動重新 <code>kubectl apply</code>，主要服務卻沒有辦法自動重啟(因為大部分都需要重啟才能吃到新的設定Ex: Nginx)，這時候只能手動將服務砍掉讓它重啟，這使得使用上有那麼一點不便利，如果當要修改的設定檔一多，所耗費的時間也就越多，如果能夠讓設定檔有異動時，服務可以自動重啟，那就再好不過了。</p>
<span id="more"></span>

<p>為了解決這個問題，下面將要介紹一款開源的套件 Reloader，將它安裝在 K8s 內，並在 <code>annatation</code> 多加一些設定，Reloader 就會自動幫你偵測服務所掛載的 Configmap/Secret 資料是否有異動，當有異動時就會幫忙將做 Rolling Update</p>
<h2 id="Reloader的安裝"><a href="#Reloader的安裝" class="headerlink" title="Reloader的安裝"></a>Reloader的安裝</h2><p>安裝 Reloader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;stakater&#x2F;Reloader&#x2F;master&#x2F;deployments&#x2F;kubernetes&#x2F;reloader.yaml</span><br></pre></td></tr></table></figure>

<p>在預設下，Reloader 會部署在 <code>default</code> 的 namespace 且會幫你監視「所有 namespace」的 <code>Secret</code>、<code>ConfigMap</code> 是否有異動</p>
<blockquote>
<p>By default, Reloader gets deployed in <code>default</code> namespace and watches changes <code>secrets</code> and <code>configmaps</code> in all namespaces.</p>
</blockquote>
<p>安裝後，在 K8s <code>default</code> namespace 會多一個 stakater-reloader 服務</p>
<h2 id="Reloader的使用"><a href="#Reloader的使用" class="headerlink" title="Reloader的使用"></a>Reloader的使用</h2><p>安裝後，我們必須告訴 Reloader，要請他幫我們監視哪個服務所掛載的 <code>Secret</code> 或 <code>ConfigMap</code>，</p>
<p>假設 Deployment 名字是 foo，而他掛一個 ConfigMap 名稱叫 foo-configmap，然後在 deployment Object 的 annotation 加上主要設定，如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">configmap.reloader.stakater.com/reload:</span> <span class="string">&quot;foo-configmap&quot;</span></span><br></pre></td></tr></table></figure>

<p>同樣的，如果要監視 <code>Secret</code> 也是一樣的方式，只是 annotation 要稍微改一下，由 <code>configmap.reloader.stakater.com/reload</code> 改成 <code>secret.reloader.stakater.com/reload</code>，冒號後面的值則是帶入 <code>Secret</code> 名稱</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">secret.reloader.stakater.com/reload:</span> <span class="string">&quot;foo-secret&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果 Deployment 同時掛載多個 <code>Secret</code> 或 <code>ConfigMap</code>，則以逗號分開，例如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">configmap.reloader.stakater.com/reload:</span> <span class="string">&quot;foo-configmap,bar-configmap,baz-configmap&quot;</span></span><br></pre></td></tr></table></figure>

<p>當然也可以讓 Reloader 自行判斷，<code>reloader.stakater.com/auto: &quot;true&quot;</code> 會自行判斷 Deployment 是否有掛載 ConfigMap 或 Secret 當掛載的資料有異動時會自動重啟 Pod</p>
<blockquote>
<p><code>reloader.stakater.com/auto: &quot;true&quot;</code> will only reload the pod, if the configmap or secret is used (as a volume mount or as an env) in <code>DeploymentConfigs/Deployment/Daemonsets/Statefulsets</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">reloader.stakater.com/auto:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Reloader的實際應用"><a href="#Reloader的實際應用" class="headerlink" title="Reloader的實際應用"></a>Reloader的實際應用</h2><p>如果懶得自己寫 YAML 的朋友，可以拿下面的 Nginx 範例部署到環境內做測試，Deployment/ConfigMap 都部署後，可以試著修改 ConfigMap 中 Nginx 設定檔內容，在重新部署，就會發現 Nginx 神奇的自己重新啟動。</p>
<p>Deployment</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-reloader-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-reloader-test</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">configmap.reloader.stakater.com/reload:</span> <span class="string">&quot;nginx-config&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-reloader-test</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-reloader-test</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-reloader-test</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.21.1</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf-volume</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx-config</span></span><br></pre></td></tr></table></figure>

<p>ConfiMap</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">nginx.conf:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">server</span> &#123;</span><br><span class="line">        <span class="string">listen</span>       <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line">        <span class="string">root</span>   <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">        <span class="string">index</span>  <span class="string">index.php</span> <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span></span><br><span class="line">        <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> &#123;</span><br><span class="line">            <span class="string">root</span>   <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">            <span class="string">try_files</span> <span class="string">$uri</span> <span class="string">$uri/</span> <span class="string">=404;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="文後討論"><a href="#文後討論" class="headerlink" title="文後討論"></a>文後討論</h2><p>官方 GitHub 底下還有蠻多可以調整的參數，如果有特殊需求的朋友，可以到 <a href="https://github.com/stakater/Reloader">官方GitHub</a> 去挖寶，或許會找到你所需要，尤其是在 NOTES 的區塊，可以考慮好好讀一下</p>
<p><a href="https://github.com/stakater/Reloader#notes">https://github.com/stakater/Reloader#notes</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://github.com/stakater/Reloader">https://github.com/stakater/Reloader</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>PHP-FPM行程優化</title>
    <url>/posts/66a05136/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期公司內部 PHP-FPM 有頂到一些行程相關的上限，導致網頁要處理後端程式時無法處理，進而造成服務異常。 而這樣子的問題不外乎可以從 LOG 去看到一些觸發到這個問題的根本原因是什麼。</p>
<p>以下列了兩個行程不夠時常見的 Error Log</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">WARNING: [pool www] server reached pm.max_children setting (5), consider raising it</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">WARNING: [pool www] seems busy (you may need to increase pm.start_servers, or pm.min/max_spare_servers), spawning 32 children, there are 0 idle, and 19 total child</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>PHP-FPM 行程優化相關參數，以下為預設值，需要依照每台機器狀態不同去調教</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pm = dynamic</span><br><span class="line">pm.max_children = 5</span><br><span class="line">pm.start_servers = 2</span><br><span class="line">pm.min_spare_servers = 1</span><br><span class="line">pm.max_spare_servers = 3</span><br><span class="line"></span><br><span class="line">pm.max_requests = 500</span><br><span class="line">pm.process_idle_timeout = 10s # 需搭配 pm = ondemand</span><br></pre></td></tr></table></figure>

<p>以下會針對每個項目去解釋其用途</p>
<h2 id="pm-Process-Manager"><a href="#pm-Process-Manager" class="headerlink" title="pm (Process Manager)"></a>pm (Process Manager)</h2><p>pm 為行程管理(Process Manager) 的縮寫，此參數主要是在設定 pm 要使用哪種模式來管理行程，可以區分兩大類型，共三種模式可以選擇，預設是使用 dynamic</p>
<h3 id="固定行程數量"><a href="#固定行程數量" class="headerlink" title="固定行程數量"></a>固定行程數量</h3><ul>
<li>static: 設定此模式，只有 <code>pm.max_children</code> 參數會生效，行程數量則根據 <code>pm.max_children</code>，效能較好，因為 child process 會保持一個固定的數量，但是比較佔記憶體，因為即便請求較少量時，依然會佔用，所以較不建議使用此模式</li>
</ul>
<h3 id="動態行程數量"><a href="#動態行程數量" class="headerlink" title="動態行程數量"></a>動態行程數量</h3><p>皆根據 <code>pm.max_children</code>、<code>pm.start_servers</code>、<code>pm.min_spare_servers</code>、<code>pm.max_spare_servers</code> 動態調整</p>
<ul>
<li>dynamic: 根據使用量用多寡開行程，但當使用量比較低時，會保留固定行程(根據 <code>pm.min_spare_servers</code> 或 <code>pm.max_spare_servers</code>)，隨時等著接收新的連線</li>
<li>ondemand: 用多少量就開多少行程</li>
</ul>
<h4 id="dynamic-實際運作"><a href="#dynamic-實際運作" class="headerlink" title="dynamic 實際運作"></a>dynamic 實際運作</h4><p>當我們設定 <code>pm = dynamic</code> 並啟動時，首先會產生一定數量的行程(根據 <code>pm.start_servers</code>)，此參數可以想像成是最小數量的子程序，而最大數量的子程序則根據 <code>pm.max_children</code>，有了最大和最小子程序數量，也就是說服務過程中子程序數量會在最大和最小子程序數量間變化。</p>
<p>而閒置的子程序數量則由 <code>pm.min_spare_servers</code>、<code>pm.max_spare_servers</code> 控制，超過 <code>pm.max_spare_servers</code> 的閒置子程序則會被 Kill。</p>
<p>因為 dynamic 模式可以針對伺服器的回應做最大的優化，但相反的代價是可能造成更多記憶體的佔用，這邊舉例來說，假設 <code>pm.max_spare_servers = 10</code>、<code>pm.max_children = 20</code>，在某個尖峰時段，這時候最大數量的子程序 20 個都處於忙碌狀態，0個閒置的子程序，過了尖峰時段，請求下降，而當初忙碌的 20 個子程序目前處於閒置狀態，此時 PHP-FPM 只會 Kill 掉 10 個子程序，而最後剩下 10 個閒置的子程序來等待請求，這也就是會造成在尖峰後請求數大量減少後，記憶體卻沒有大量降低的主要原因，而如果把主機重啟，記憶體則會將得更低，這是因為重啟用子程序數量會變成最小閒置行程數量(<code>pm.min_spare_servers</code>)</p>
<h4 id="ondemand-實際運作"><a href="#ondemand-實際運作" class="headerlink" title="ondemand 實際運作"></a>ondemand 實際運作</h4><p><code>pm = ondemand</code> 的運作方式與 dynamic 恰好相反，dynamic 針對伺服器的回應做最大的優化，而 ondemand 則是最佳化記憶體。</p>
<p>而運作方式是，每個閒置的子程序在持續閒置超過 <code>pm.process_idle_timeout</code> 設定的時間，就會被 Kill 掉，這樣的模式讓主機在尖峰時期過後可以自然地降低記憶體的使用率，如果長時間都沒有請求連線時，只會有一個 PHP-FPM 主程序。</p>
<p>那壞處則是，如果遇到尖峰時期，或 <code>pm.process_idle_timeout</code> 設定得太短的話，會造成伺服器頻繁的建立子程序，而造成效能不佳</p>
<h2 id="pm-max-children-最大行程數量"><a href="#pm-max-children-最大行程數量" class="headerlink" title="pm.max_children(最大行程數量)"></a>pm.max_children(最大行程數量)</h2><p><code>pm.max_children</code> 參數在 <code>pm</code> 等於 <code>static</code> 即為開啟的行程數，而在 <code>dynamic</code> 與 <code>ondemand</code> 模式下，則是代表最大可開啟的行程數量。</p>
<p>最大行程數量的多寡是根據本身主機的記憶體大小來決定，當記憶體越大時，就可以設定較多的行程數量。 此設定值如果設太小的話會造成處理請求的速度下降，設定太大的話會造成當機，因為記憶體耗盡，所以要依硬體資源來調較。</p>
<p>可以利用以下指令去查詢行程使用的記憶體量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -ylC php-fpm --sort:rss</span><br><span class="line"></span><br><span class="line">S   UID     PID    PPID  C PRI  NI   RSS    SZ WCHAN  TTY          TIME CMD</span><br><span class="line">S     0       1       0  0  80   0  4760 20195 do_epo ?        00:02:11 php-fpm</span><br><span class="line">S    33       9       1  0  80   0 20260 22581 -      ?        00:01:20 php-fpm</span><br><span class="line">S    33       8       1  0  80   0 20464 22582 -      ?        00:01:42 php-fpm</span><br><span class="line">S    33       7       1  0  80   0 20476 22584 -      ?        00:01:43 php-fpm</span><br></pre></td></tr></table></figure>

<p>RSS 欄位為子程序使用的記憶體大小，單位為KB，20476 約莫 20MB，但是因為每個子程序所使用的記憶體大小都不太一樣，所以我們可以使用下面的指令來求出子程序平均使用記憶體大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps --no-headers -o &quot;rss,cmd&quot; -C php-fpm | awk &#39;&#123; sum+&#x3D;$1 &#125; END &#123; printf (&quot;%d%s\n&quot;, sum&#x2F;NR&#x2F;1024,&quot;Mb&quot;) &#125;&#39;</span><br></pre></td></tr></table></figure>

<p>至於 <code>pm.max_children</code> 應該要設定多少才合理，以下有一個計算公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.max_children &#x3D; Total RAM &#x2F; Max child process size</span><br></pre></td></tr></table></figure>

<blockquote>
<p>這邊的 Total RAM 需要扣除已經使用的記憶體，例如系統或其他程序使用後所剩餘的記憶體</p>
</blockquote>
<h2 id="pm-start-servers-初始行程數量"><a href="#pm-start-servers-初始行程數量" class="headerlink" title="pm.start_servers(初始行程數量)"></a>pm.start_servers(初始行程數量)</h2><p><code>pm.start_servers</code> 可設定 PHP-FPM 服務在一開始啟動時，要配置多少個行程</p>
<p><code>pm.start_servers</code> 同樣有一個計算公式可以參考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.start_servers &#x3D; min_spare_servers + (max_spare_servers - min_spare_servers) &#x2F; 2</span><br></pre></td></tr></table></figure>

<h2 id="pm-min-spare-servers-最小閒置行程數量"><a href="#pm-min-spare-servers-最小閒置行程數量" class="headerlink" title="pm.min_spare_servers(最小閒置行程數量)"></a>pm.min_spare_servers(最小閒置行程數量)</h2><p><code>pm.min_spare_servers</code> 設定 PHP-FPM 最小閒置行程的數量</p>
<h2 id="pm-max-spare-servers-最大閒置行程數量"><a href="#pm-max-spare-servers-最大閒置行程數量" class="headerlink" title="pm.max_spare_servers(最大閒置行程數量)"></a>pm.max_spare_servers(最大閒置行程數量)</h2><p><code>pm.max_spare_servers</code> 設定 PHP-FPM 最大閒置行程的數量</p>
<blockquote>
<p>這邊需要注意的是 <code>pm.max_spare_servers</code> 的值只能小於等於 <code>pm.max_children</code></p>
</blockquote>
<h2 id="pm-max-requests-單一行程可處理連線數"><a href="#pm-max-requests-單一行程可處理連線數" class="headerlink" title="pm.max_requests(單一行程可處理連線數)"></a>pm.max_requests(單一行程可處理連線數)</h2><p><code>pm.max_requests</code> 可設定單一 PHP-FPM 最多可以處理多少個連線，當一個行程處理的連線數達到設定值時，此行程會被 Kill 掉，而重新產生另一個新的行程</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://kejyuntw.gitbooks.io/ubuntu-learning-notes/content/web/php/web-php-max-children.html">https://kejyuntw.gitbooks.io/ubuntu-learning-notes/content/web/php/web-php-max-children.html</a></li>
<li><a href="https://support.plesk.com/hc/en-us/articles/360011988053-How-to-calculate-pm-max-children-value-">https://support.plesk.com/hc/en-us/articles/360011988053-How-to-calculate-pm-max-children-value-</a></li>
<li><a href="https://www.mdeditor.tw/pl/p9Vf/zh-tw">https://www.mdeditor.tw/pl/p9Vf/zh-tw</a></li>
</ul>
]]></content>
      <categories>
        <category>PHP-FPM</category>
      </categories>
  </entry>
</search>
